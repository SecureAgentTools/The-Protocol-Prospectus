<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Governance & Stewardship - AAA+ Cinematic Experience | The Protocol</title>
    
    <!-- SEO & Open Graph -->
    <meta name="description" content="Experience The Protocol's decentralized governance in stunning 3D. A cinematic journey through sovereignty, stewardship, and collective wisdom.">
    <meta property="og:title" content="The Protocol: Governance & Stewardship Model">
    <meta property="og:description" content="Witness the future of decentralized governance through cutting-edge 3D visualization with spatial audio and real-time consensus mechanisms.">
    <meta property="og:image" content="https://www.theprotocol.cloud/preview.png">
    
    <!-- Three.js r128 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- GSAP for cinematic animations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    
    <!-- Tone.js for spatial audio -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --governance-primary: #10B981;
            --governance-secondary: #3B82F6;
            --governance-accent: #8B5CF6;
            --governance-warning: #F59E0B;
            --governance-danger: #EF4444;
            --bg-void: #000000;
            --bg-deep: #0a0a0a;
            --text-bright: #FFFFFF;
            --text-primary: #F8FAFC;
            --text-secondary: #94A3B8;
            --gradient-governance: linear-gradient(135deg, #10B981 0%, #3B82F6 100%);
            --gradient-council: linear-gradient(135deg, #8B5CF6 0%, #10B981 100%);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg-void);
            color: var(--text-primary);
            overflow: hidden;
            cursor: none;
        }

        /* Custom Cursor */
        .custom-cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            border: 2px solid var(--governance-primary);
            border-radius: 50%;
            pointer-events: none;
            z-index: 10000;
            transition: all 0.1s ease;
            mix-blend-mode: difference;
        }

        .custom-cursor.hover {
            width: 40px;
            height: 40px;
            background: rgba(16, 185, 129, 0.2);
        }

        .custom-cursor::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background: var(--governance-primary);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        /* Loading Screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-void);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s ease;
        }

        .loading-title {
            font-size: clamp(2rem, 5vw, 4rem);
            font-weight: 900;
            margin-bottom: 2rem;
            background: var(--gradient-governance);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.8; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.05); }
        }

        .loading-progress {
            width: 300px;
            height: 4px;
            background: rgba(16, 185, 129, 0.2);
            border-radius: 2px;
            overflow: hidden;
            position: relative;
        }

        .loading-progress-bar {
            height: 100%;
            background: var(--gradient-governance);
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.5);
        }

        .loading-status {
            margin-top: 1rem;
            color: var(--text-secondary);
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        /* Main Canvas */
        #governance-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* UI Overlay */
        .ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        /* Universal Navigation Header */
        .nav-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(10, 10, 10, 0.7);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(59, 130, 246, 0.1);
            z-index: 1000;
            pointer-events: auto;
            transition: all 0.3s ease;
        }

        /* Dropdown hover effect */
        .nav-item:hover .dropdown {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .nav-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            height: 80px;
        }

        .nav-logo {
            font-size: 1.5rem;
            font-weight: 900;
            background: linear-gradient(135deg, #3B82F6 0%, #8B5CF6 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-decoration: none;
            letter-spacing: -0.02em;
        }

        .nav-menu {
            display: flex;
            gap: 2rem;
            align-items: center;
        }

        .nav-item {
            position: relative;
        }

        .nav-link {
            color: #94A3B8;
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0;
        }

        .nav-link:hover {
            color: #F8FAFC;
        }

        .dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            background: rgba(10, 10, 10, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 0.75rem;
            padding: 0.5rem;
            min-width: 220px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            margin-top: 0.5rem;
        }

        .nav-item:hover .dropdown {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .dropdown-item {
            display: block;
            padding: 0.75rem 1rem;
            color: #94A3B8;
            text-decoration: none;
            font-weight: 400;
            transition: all 0.3s ease;
            border-radius: 0.5rem;
        }

        .dropdown-item:hover {
            background: rgba(59, 130, 246, 0.1);
            color: #F8FAFC;
            transform: translateX(4px);
        }

        .nav-cta {
            background: linear-gradient(135deg, #3B82F6 0%, #8B5CF6 100%);
            color: #F8FAFC;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            text-decoration: none;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .nav-cta:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(59, 130, 246, 0.3);
        }

        .mobile-menu-toggle {
            display: none;
            background: none;
            border: none;
            color: #F8FAFC;
            font-size: 1.5rem;
            cursor: pointer;
        }

        @media (max-width: 768px) {
            .nav-menu {
                display: none;
            }
            
            .mobile-menu-toggle {
                display: block;
            }
        }

        /* Oracle Documentation Button */
        .oracle-button {
            position: fixed;
            bottom: 3rem;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #8B5CF6 0%, #EC4899 100%);
            color: #F8FAFC;
            padding: 0.875rem 2rem;
            border-radius: 50px;
            text-decoration: none;
            font-weight: 600;
            font-size: 1rem;
            box-shadow: 0 10px 40px rgba(139, 92, 246, 0.4);
            transition: all 0.3s ease;
            z-index: 300;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .oracle-button:hover {
            transform: translateX(-50%) translateY(-2px);
            box-shadow: 0 15px 50px rgba(139, 92, 246, 0.5);
        }

        .oracle-button::before {
            content: 'üìú';
            font-size: 1.2rem;
        }

        /* View Mode Selector */
        .view-modes {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 1rem;
            background: rgba(10, 10, 10, 0.8);
            padding: 0.5rem;
            border-radius: 100px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(16, 185, 129, 0.2);
            pointer-events: auto;
            z-index: 200;
        }

        .view-mode-btn {
            padding: 0.75rem 1.5rem;
            background: transparent;
            color: var(--text-secondary);
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            font-size: 0.9rem;
            position: relative;
            overflow: hidden;
        }

        .view-mode-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 0;
            height: 100%;
            background: var(--gradient-governance);
            transition: width 0.3s ease;
            z-index: -1;
        }

        .view-mode-btn:hover {
            color: var(--text-bright);
            transform: translateY(-2px);
        }

        .view-mode-btn.active {
            color: var(--text-bright);
            background: var(--gradient-governance);
        }

        /* Control Panel */
        .control-panel {
            position: fixed;
            top: 120px;
            right: 2rem;
            background: rgba(10, 10, 10, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(16, 185, 129, 0.2);
            border-radius: 1rem;
            padding: 1.5rem;
            pointer-events: auto;
            width: 300px;
            max-height: calc(100vh - 140px);
            overflow-y: auto;
            z-index: 200;
        }

        .control-section {
            margin-bottom: 2rem;
        }

        .control-section:last-child {
            margin-bottom: 0;
        }

        .control-title {
            font-size: 1.1rem;
            font-weight: 700;
            margin-bottom: 1rem;
            color: var(--governance-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .control-button {
            width: 100%;
            padding: 0.75rem;
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.3);
            color: var(--text-bright);
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .control-button:hover {
            background: rgba(16, 185, 129, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(16, 185, 129, 0.3);
        }

        /* Info Panel */
        .info-panel {
            position: fixed;
            bottom: 2rem;
            left: 2rem;
            background: rgba(10, 10, 10, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(16, 185, 129, 0.2);
            border-radius: 1rem;
            padding: 1.5rem;
            pointer-events: auto;
            max-width: 400px;
            max-height: 40vh;
            overflow-y: auto;
            z-index: 200;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease;
        }

        .info-panel.visible {
            opacity: 1;
            transform: translateY(0);
        }

        /* FPS Display */
        .fps-display {
            position: fixed;
            top: 100px;
            left: 2rem;
            background: rgba(10, 10, 10, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(16, 185, 129, 0.2);
            border-radius: 0.5rem;
            padding: 1rem;
            font-family: 'Courier New', monospace;
            font-size: 0.875rem;
            pointer-events: auto;
            z-index: 200;
            min-width: 150px;
        }

        .fps-display .fps-value {
            color: var(--governance-primary);
            font-weight: bold;
            font-size: 1.2rem;
        }

        /* Stats Display */
        .stats-display {
            position: fixed;
            top: 180px;  /* Positioned below FPS */
            left: 2rem;
            background: rgba(10, 10, 10, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(16, 185, 129, 0.2);
            border-radius: 0.5rem;
            padding: 1rem;
            font-family: 'Courier New', monospace;
            font-size: 0.875rem;
            pointer-events: auto;
            z-index: 200;
            min-width: 200px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            color: var(--text-secondary);
        }

        .stat-value {
            color: var(--governance-primary);
            font-weight: bold;
        }

        /* Tier Legend */
        .tier-legend {
            position: fixed;
            top: 380px;  /* Positioned below stats */
            left: 2rem;
            background: rgba(10, 10, 10, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(16, 185, 129, 0.2);
            border-radius: 0.5rem;
            padding: 1rem;
            pointer-events: auto;
            z-index: 200;
        }

        .tier-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        .tier-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            box-shadow: 0 0 10px currentColor;
        }

        /* Audio Controls - Fixed positioning */
        .audio-controls {
            position: fixed;
            bottom: 2rem;  /* Bottom position */
            left: 2rem;    /* Moved to left to avoid overlap */
            display: flex;
            align-items: center;
            gap: 1rem;
            background: rgba(10, 10, 10, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(16, 185, 129, 0.2);
            border-radius: 50px;
            padding: 0.75rem 1.5rem;
            pointer-events: auto;
            z-index: 300;  /* Increased z-index */
        }

        .audio-toggle {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 1.5rem;
            transition: all 0.3s ease;
        }

        .audio-toggle:hover {
            color: var(--governance-primary);
            transform: scale(1.1);
        }

        .audio-toggle.active {
            color: var(--governance-primary);
        }

        .volume-slider {
            width: 100px;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(16, 185, 129, 0.2);
            border-radius: 2px;
            outline: none;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--governance-primary);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .volume-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 10px rgba(16, 185, 129, 0.5);
        }

        /* Quality Settings */
        .quality-settings {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .quality-btn {
            flex: 1;
            padding: 0.5rem;
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.3);
            color: var(--text-secondary);
            border-radius: 0.25rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.75rem;
            text-align: center;
        }

        .quality-btn.active {
            background: var(--gradient-governance);
            color: var(--text-bright);
            border-color: transparent;
        }

        /* Help Overlay */
        .help-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }

        .help-content {
            background: rgba(10, 10, 10, 0.95);
            border: 1px solid rgba(16, 185, 129, 0.3);
            border-radius: 1rem;
            padding: 2rem;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .help-title {
            font-size: 2rem;
            font-weight: 900;
            margin-bottom: 1rem;
            background: var(--gradient-governance);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .help-section {
            margin-bottom: 1.5rem;
        }

        .help-section h3 {
            color: var(--governance-primary);
            margin-bottom: 0.5rem;
        }

        .help-shortcut {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid rgba(16, 185, 129, 0.1);
        }

        .key {
            background: rgba(16, 185, 129, 0.1);
            padding: 0.25rem 0.75rem;
            border-radius: 0.25rem;
            font-family: monospace;
            font-size: 0.875rem;
            color: var(--governance-primary);
            border: 1px solid rgba(16, 185, 129, 0.3);
        }

        /* Component Labels - Fixed positioning */
        .component-label {
            position: absolute;
            background: rgba(10, 10, 10, 0.9);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            color: var(--text-bright);
            pointer-events: none;
            z-index: 150;
            opacity: 0;
            transform: translateY(0);
            transition: all 0.3s ease;
            white-space: nowrap;
            border: 1px solid rgba(16, 185, 129, 0.2);
            font-weight: 600;
            max-width: 200px;
            visibility: hidden;
        }

        .component-label.visible {
            opacity: 1;
            visibility: visible;
        }

        /* Cinematic UI */
        .cinematic-ui {
            position: fixed;
            top: 2rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 10, 10, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(16, 185, 129, 0.2);
            border-radius: 50px;
            padding: 0.5rem 1rem;
            pointer-events: auto;
            z-index: 200;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .cinematic-ui.visible {
            opacity: 1;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .control-panel {
                display: none;
            }
            
            .tier-legend {
                display: none;
            }
            
            .stats-display {
                display: none;
            }
            
            .audio-controls {
                bottom: 1rem;
                right: 1rem;
                padding: 0.5rem 1rem;
            }
            
            .view-modes {
                flex-wrap: wrap;
                max-width: 90vw;
                top: 90px;
                gap: 0.5rem;
            }
            
            .view-mode-btn {
                font-size: 0.8rem;
                padding: 0.5rem 1rem;
            }
        }
    </style>
</head>
<body>
    <!-- Custom Cursor -->
    <div class="custom-cursor" id="customCursor"></div>

    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <h1 class="loading-title">Governance & Stewardship</h1>
        <div class="loading-progress">
            <div class="loading-progress-bar" id="loadingProgress"></div>
        </div>
        <div class="loading-status" id="loadingStatus">Initializing governance systems...</div>
    </div>

    <!-- Main Canvas -->
    <canvas id="governance-canvas"></canvas>

    <!-- UI Overlay -->
    <div class="ui-overlay">
        <!-- Universal Navigation -->
        <header class="nav-header">
            <div class="nav-container">
                <a href="/index.html" class="nav-logo">The Protocol</a>
                <nav class="nav-menu">
                    <div class="nav-item">
                        <a href="#" class="nav-link">
                            Ecosystem
                            <svg width="12" height="12" viewBox="0 0 12 12" fill="none" style="transition: transform 0.3s ease;">
                                <path d="M3 4.5L6 7.5L9 4.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                        </a>
                        <div class="dropdown">
                            <a href="/technical-page.html" class="dropdown-item">Technical Architecture</a>
                            <a href="/federation.html" class="dropdown-item">Federation Model</a>
                            <a href="/zkp-page.html" class="dropdown-item">Zero-Knowledge Proofs</a>
                            <a href="/attestation.html" class="dropdown-item">Attestation Network</a>
                            <a href="/governance.html" class="dropdown-item" style="background: rgba(59, 130, 246, 0.1); color: #F8FAFC;">Governance</a>
                        </div>
                    </div>
                    <a href="/developers-page.html" class="nav-link">For Developers</a>
                    <a href="#" class="nav-link" style="display: flex; align-items: center; gap: 0.5rem;">
                        Developer Portal
                        <svg width="12" height="12" viewBox="0 0 12 12" fill="none">
                            <path d="M4.5 2.5L8.5 2.5L8.5 6.5M8.5 2.5L2.5 8.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    </a>
                    <a href="#application" class="nav-cta">Join Beta</a>
                </nav>
                <button class="mobile-menu-toggle" aria-label="Toggle menu">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
                        <path d="M3 12H21M3 6H21M3 18H21" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                    </svg>
                </button>
            </div>
        </header>

        <!-- View Mode Selector -->
        <div class="view-modes">
            <button class="view-mode-btn active" data-mode="council">Council View</button>
            <button class="view-mode-btn" data-mode="flow">Voting Flow</button>
            <button class="view-mode-btn" data-mode="network">Network View</button>
            <button class="view-mode-btn" data-mode="timeline">Timeline</button>
            <button class="view-mode-btn" data-mode="cinematic">Cinematic</button>
        </div>

        <!-- FPS Display -->
        <div class="fps-display">
            <div>FPS: <span class="fps-value" id="fpsCounter">60</span></div>
        </div>

        <!-- Stats Display -->
        <div class="stats-display">
            <div class="stat-row">
                <span>Active Proposals:</span>
                <span class="stat-value" id="proposalCount">0</span>
            </div>
            <div class="stat-row">
                <span>Consensus Level:</span>
                <span class="stat-value" id="consensusLevel">0%</span>
            </div>
            <div class="stat-row">
                <span>Active Nodes:</span>
                <span class="stat-value" id="nodeCount">40</span>
            </div>
            <div class="stat-row">
                <span>Energy Flow:</span>
                <span class="stat-value" id="energyFlow">Normal</span>
            </div>
        </div>

        <!-- Tier Legend -->
        <div class="tier-legend">
            <div class="tier-item">
                <div class="tier-dot" style="background: #8B5CF6;"></div>
                <span>Protocol Council</span>
            </div>
            <div class="tier-item">
                <div class="tier-dot" style="background: #3B82F6;"></div>
                <span>Technical Committee</span>
            </div>
            <div class="tier-item">
                <div class="tier-dot" style="background: #10B981;"></div>
                <span>Community Forum</span>
            </div>
        </div>

        <!-- Control Panel -->
        <div class="control-panel">
            <div class="control-section">
                <h3 class="control-title">
                    <span>‚ö°</span> Governance Actions
                </h3>
                <button class="control-button" id="createProposalBtn">Create Proposal</button>
                <button class="control-button" id="initiateVoteBtn">Initiate Vote</button>
                <button class="control-button" id="showConsensusBtn">Show Consensus</button>
                <button class="control-button" id="resetGovernanceBtn">Reset Chamber</button>
            </div>

            <div class="control-section">
                <h3 class="control-title">
                    <span>üé¨</span> Camera Presets
                </h3>
                <button class="control-button camera-preset" data-camera="orbit">Orbit Chamber</button>
                <button class="control-button camera-preset" data-camera="council">Council Focus</button>
                <button class="control-button camera-preset" data-camera="timeline">Timeline View</button>
                <button class="control-button camera-preset" data-camera="matrix">Matrix View</button>
            </div>

            <div class="control-section">
                <h3 class="control-title">
                    <span>‚öôÔ∏è</span> Performance
                </h3>
                <div class="quality-settings">
                    <button class="quality-btn" data-quality="low">Low</button>
                    <button class="quality-btn active" data-quality="medium">Medium</button>
                    <button class="quality-btn" data-quality="high">High</button>
                    <button class="quality-btn" data-quality="ultra">Ultra</button>
                </div>
            </div>

            <div class="control-section">
                <h3 class="control-title">
                    <span>üëÅÔ∏è</span> Visualization
                </h3>
                <label style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                    <input type="checkbox" id="showParticles" checked>
                    <span>Energy Particles</span>
                </label>
                <label style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                    <input type="checkbox" id="showConnections" checked>
                    <span>Governance Links</span>
                </label>
                <label style="display: flex; align-items: center; gap: 0.5rem;">
                    <button class="control-button" id="labelToggle" style="margin-bottom: 0;">Node Labels: Full</button>
                </label>
            </div>
        </div>

        <!-- Info Panel -->
        <div class="info-panel" id="infoPanel">
            <h3 style="color: var(--governance-primary); margin-bottom: 0.5rem;">Node Details</h3>
            <p id="infoPanelContent" style="color: var(--text-secondary); line-height: 1.6;"></p>
        </div>

        <!-- Audio Controls - Fixed to bottom right -->
        <div class="audio-controls">
            <button class="audio-toggle" id="audioToggle">üîá</button>
            <input type="range" class="volume-slider" id="volumeSlider" min="0" max="100" value="70">
        </div>

        <!-- Help Overlay -->
        <div class="help-overlay" id="helpOverlay">
            <div class="help-content">
                <h2 class="help-title">Keyboard Shortcuts</h2>
                
                <div class="help-section">
                    <h3>Navigation</h3>
                    <div class="help-shortcut">
                        <span>Rotate Camera</span>
                        <span class="key">Mouse Drag</span>
                    </div>
                    <div class="help-shortcut">
                        <span>Zoom</span>
                        <span class="key">Mouse Wheel</span>
                    </div>
                    <div class="help-shortcut">
                        <span>Reset View</span>
                        <span class="key">R</span>
                    </div>
                </div>

                <div class="help-section">
                    <h3>Actions</h3>
                    <div class="help-shortcut">
                        <span>Create Proposal</span>
                        <span class="key">P</span>
                    </div>
                    <div class="help-shortcut">
                        <span>Initiate Vote</span>
                        <span class="key">V</span>
                    </div>
                    <div class="help-shortcut">
                        <span>Toggle Audio</span>
                        <span class="key">M</span>
                    </div>
                    <div class="help-shortcut">
                        <span>Fullscreen</span>
                        <span class="key">F</span>
                    </div>
                </div>

                <div class="help-section">
                    <h3>View Modes</h3>
                    <div class="help-shortcut">
                        <span>Council View</span>
                        <span class="key">1</span>
                    </div>
                    <div class="help-shortcut">
                        <span>Voting Flow</span>
                        <span class="key">2</span>
                    </div>
                    <div class="help-shortcut">
                        <span>Network View</span>
                        <span class="key">3</span>
                    </div>
                    <div class="help-shortcut">
                        <span>Timeline</span>
                        <span class="key">4</span>
                    </div>
                    <div class="help-shortcut">
                        <span>Cinematic</span>
                        <span class="key">5</span>
                    </div>
                </div>

                <div class="help-section">
                    <h3>Other</h3>
                    <div class="help-shortcut">
                        <span>Show Help</span>
                        <span class="key">?</span>
                    </div>
                    <div class="help-shortcut">
                        <span>Close Help</span>
                        <span class="key">ESC</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Cinematic UI -->
        <div class="cinematic-ui" id="cinematicUI">
            <span>Press ESC to exit cinematic mode</span>
        </div>
    </div>

    <script>
        // Initialize Three.js Scene
        let scene, camera, renderer;
        let raycaster, mouse;
        let audioEnabled = false;
        let currentView = 'council';
        let quality = 'medium';
        let stats = {
            fps: 60,
            proposalCount: 0,
            consensusLevel: 0,
            nodeCount: 40,
            energyFlow: 'Normal'
        };

        // Scene objects
        let governanceNodes = [];
        let energyParticles = [];
        let connections = [];
        let votingFlows = [];
        let componentLabels = [];

        // Camera animations
        let orbitAnimation, councilAnimation, timelineAnimation, matrixAnimation;
        let cinematicActive = false;

        // FPS tracking
        let frameCount = 0;
        let lastFpsUpdate = performance.now();
        let fpsUpdateInterval = 250;

        // Label state: 0 = off, 1 = full names, 2 = short names
        let labelState = 1;

        // Initialize Tone.js
        let synth, reverb, panner;

        // Governance Chamber Configuration
        const chamberConfig = {
            tiers: [
                {
                    name: 'Protocol Council',
                    count: 8,
                    radius: 8,
                    height: 10,
                    color: 0x8B5CF6,
                    scale: 1.5
                },
                {
                    name: 'Technical Committee',
                    count: 12,
                    radius: 12,
                    height: 5,
                    color: 0x3B82F6,
                    scale: 1.2
                },
                {
                    name: 'Community Forum',
                    count: 20,
                    radius: 16,
                    height: 0,
                    color: 0x10B981,
                    scale: 1.0
                }
            ],
            center: {
                name: 'Voting Core',
                color: 0xF59E0B,
                scale: 2.0
            }
        };

        // Enhanced Custom Shaders with tier-specific effects
        const governanceVertexShader = `
            uniform float time;
            uniform float pulseIntensity;
            uniform float tier;
            
            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vPosition;
            varying vec3 vWorldPosition;
            varying float vDisplacement;
            
            void main() {
                vUv = uv;
                vNormal = normalize(normalMatrix * normal);
                vPosition = position;
                
                vec3 pos = position;
                
                // Tier-specific displacement patterns
                float displacement = 0.0;
                if (tier == 0.0) {
                    // Protocol Council - majestic slow pulse
                    displacement = sin(time * 1.5 + position.y * 0.5) * pulseIntensity * 0.15;
                } else if (tier == 1.0) {
                    // Technical Committee - technical oscillation
                    displacement = sin(time * 2.5 + position.x * 0.8) * cos(time * 1.8 + position.z * 0.6) * pulseIntensity * 0.1;
                } else {
                    // Community Forum - energetic vibration
                    displacement = sin(time * 3.0 + length(position.xy) * 2.0) * pulseIntensity * 0.08;
                }
                
                vDisplacement = displacement;
                pos += normal * displacement;
                
                vec4 worldPosition = modelMatrix * vec4(pos, 1.0);
                vWorldPosition = worldPosition.xyz;
                
                vec4 mvPosition = viewMatrix * worldPosition;
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const governanceFragmentShader = `
            uniform vec3 color;
            uniform float time;
            uniform float opacity;
            uniform float emissiveIntensity;
            uniform float tier;
            
            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vPosition;
            varying vec3 vWorldPosition;
            varying float vDisplacement;
            
            void main() {
                // Base color with tier-specific modifications
                vec3 baseColor = color;
                
                // Fresnel effect for holographic appearance
                vec3 viewDirection = normalize(cameraPosition - vWorldPosition);
                float fresnel = pow(1.0 - abs(dot(viewDirection, vNormal)), 2.0);
                
                // Tier-specific effects
                vec3 emissive = vec3(0.0);
                
                if (tier == 0.0) {
                    // Protocol Council - Royal purple with golden edges
                    emissive = mix(baseColor, vec3(1.0, 0.8, 0.3), fresnel * 0.5) * emissiveIntensity;
                    emissive += vec3(0.5, 0.0, 1.0) * pow(fresnel, 3.0) * 0.5;
                } else if (tier == 1.0) {
                    // Technical Committee - Electric blue with data streams
                    float dataStream = sin(vUv.y * 20.0 - time * 3.0) * 0.5 + 0.5;
                    emissive = baseColor * emissiveIntensity * (1.0 + dataStream * 0.3);
                    emissive += vec3(0.0, 0.5, 1.0) * fresnel * 0.6;
                } else {
                    // Community Forum - Vibrant green with energy pulses
                    float pulse = sin(time * 4.0 + vDisplacement * 10.0) * 0.5 + 0.5;
                    emissive = baseColor * emissiveIntensity * (1.0 + pulse * 0.4);
                    emissive += vec3(0.0, 1.0, 0.5) * fresnel * 0.7;
                }
                
                // Holographic scan lines
                float scanline = sin(vWorldPosition.y * 10.0 + time * 2.0) * 0.5 + 0.5;
                emissive *= 0.9 + scanline * 0.1;
                
                // Interior glow
                float interiorGlow = smoothstep(0.0, 1.0, 1.0 - abs(vNormal.z));
                emissive += baseColor * interiorGlow * 0.2;
                
                // Final color composition
                vec3 finalColor = baseColor * 0.3 + emissive;
                
                // Edge highlight
                float edgeHighlight = pow(fresnel, 0.5);
                finalColor += vec3(1.0) * edgeHighlight * 0.2;
                
                // Alpha calculation with edge emphasis
                float alpha = opacity * (0.7 + fresnel * 0.3);
                
                gl_FragColor = vec4(finalColor, alpha);
            }
        `;

        // Enhanced Governance Node class
        class GovernanceNode {
            constructor(tier, index, tierConfig) {
                this.tier = tier;
                this.index = index;
                this.config = tierConfig;
                this.active = false;
                this.energy = 0;
                this.mesh = null;
                this.aura = null;
                this.label = null;
                this.connections = [];
                this.createMesh();
                this.createLabel();
            }

            createMesh() {
                // Different geometries for different tiers
                let geometry;
                switch (this.tier) {
                    case 0: // Protocol Council
                        geometry = new THREE.DodecahedronGeometry(this.config.scale);
                        break;
                    case 1: // Technical Committee
                        geometry = new THREE.OctahedronGeometry(this.config.scale);
                        break;
                    case 2: // Community Forum
                        geometry = new THREE.IcosahedronGeometry(this.config.scale, 1);
                        break;
                }

                // Enhanced custom shader material with tier-specific uniforms
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        color: { value: new THREE.Color(this.config.color) },
                        time: { value: 0 },
                        opacity: { value: 0.9 },
                        pulseIntensity: { value: 0.5 },
                        emissiveIntensity: { value: 0.2 },
                        tier: { value: this.tier },
                        cameraPosition: { value: camera.position }
                    },
                    vertexShader: governanceVertexShader,
                    fragmentShader: governanceFragmentShader,
                    transparent: true,
                    side: THREE.DoubleSide,
                    depthWrite: true
                });

                this.mesh = new THREE.Mesh(geometry, material);
                
                // Position in circle
                const angle = (this.index / this.config.count) * Math.PI * 2;
                this.mesh.position.x = Math.cos(angle) * this.config.radius;
                this.mesh.position.y = this.config.height;
                this.mesh.position.z = Math.sin(angle) * this.config.radius;
                
                this.mesh.castShadow = true;
                this.mesh.receiveShadow = true;
                this.mesh.userData = { node: this };

                // Create aura
                if (quality !== 'low') {
                    const auraGeometry = new THREE.SphereGeometry(this.config.scale * 1.5, 16, 16);
                    const auraMaterial = new THREE.MeshBasicMaterial({
                        color: this.config.color,
                        transparent: true,
                        opacity: 0.1,
                        side: THREE.BackSide
                    });
                    this.aura = new THREE.Mesh(auraGeometry, auraMaterial);
                    this.aura.position.copy(this.mesh.position);
                    scene.add(this.aura);
                }

                scene.add(this.mesh);
                governanceNodes.push(this);
            }

            createLabel() {
                const labelDiv = document.createElement('div');
                labelDiv.className = 'component-label';
                
                // Create both full and short labels
                const fullName = `${this.config.name} ${this.index + 1}`;
                const tierPrefix = this.tier === 0 ? 'PC' : this.tier === 1 ? 'TC' : 'CF';
                const shortName = `${tierPrefix}${this.index + 1}`;
                
                labelDiv.setAttribute('data-full', fullName);
                labelDiv.setAttribute('data-short', shortName);
                labelDiv.innerHTML = fullName;
                
                document.body.appendChild(labelDiv);
                this.label = labelDiv;
                componentLabels.push(labelDiv);
            }

            updateLabelPosition() {
                if (!this.label || !camera || !this.mesh) return;
                
                // Get actual world position of the mesh
                const worldPos = new THREE.Vector3();
                this.mesh.getWorldPosition(worldPos);
                
                // Offset label above the node
                const labelOffset = this.config.scale * 2;
                worldPos.y += labelOffset;
                
                // Create a vector for projection
                const vector = worldPos.clone();
                
                // Project to normalized device coordinates
                vector.project(camera);

                // Check if behind camera
                if (vector.z > 1) {
                    this.label.classList.remove('visible');
                    this.label.style.display = 'none';
                    return;
                }

                // Convert to screen coordinates
                const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                const y = -(vector.y * 0.5 - 0.5) * window.innerHeight;

                // Check viewport bounds
                const margin = 50;
                const labelWidth = 200; // Approximate label width
                const labelHeight = 40; // Approximate label height
                
                if (x < -labelWidth || x > window.innerWidth + labelWidth || 
                    y < -labelHeight || y > window.innerHeight + labelHeight) {
                    this.label.classList.remove('visible');
                    this.label.style.display = 'none';
                    return;
                }

                // Clamp position to keep labels on screen
                const clampedX = Math.max(margin, Math.min(window.innerWidth - margin, x));
                const clampedY = Math.max(margin, Math.min(window.innerHeight - margin, y));

                // Update label position
                this.label.style.display = 'block';
                this.label.style.left = clampedX + 'px';
                this.label.style.top = clampedY + 'px';
                this.label.style.transform = 'translate(-50%, -50%)';
                
                // Apply label state
                if (labelState === 0) {
                    this.label.classList.remove('visible');
                } else {
                    this.label.classList.add('visible');
                    // Update label text based on state
                    if (labelState === 1) {
                        this.label.innerHTML = this.label.getAttribute('data-full');
                    } else if (labelState === 2) {
                        this.label.innerHTML = this.label.getAttribute('data-short');
                    }
                }
            }

            activate() {
                this.active = true;
                this.energy = 1;
                
                gsap.to(this.mesh.scale, {
                    x: 1.3,
                    y: 1.3,
                    z: 1.3,
                    duration: 0.3,
                    ease: "back.out"
                });
                
                gsap.to(this.mesh.material.uniforms.emissiveIntensity, {
                    value: 0.8,
                    duration: 0.3
                });
                
                if (this.aura) {
                    gsap.to(this.aura.material, {
                        opacity: 0.3,
                        duration: 0.3
                    });
                    gsap.to(this.aura.scale, {
                        x: 1.2,
                        y: 1.2,
                        z: 1.2,
                        duration: 0.3
                    });
                }

                // Play sound
                if (audioEnabled && synth) {
                    playNodeSound(this.tier);
                }
            }

            deactivate() {
                this.active = false;
                
                gsap.to(this.mesh.scale, {
                    x: 1,
                    y: 1,
                    z: 1,
                    duration: 0.3
                });
                
                gsap.to(this.mesh.material.uniforms.emissiveIntensity, {
                    value: 0.2,
                    duration: 0.3
                });
                
                if (this.aura) {
                    gsap.to(this.aura.material, {
                        opacity: 0.1,
                        duration: 0.3
                    });
                    gsap.to(this.aura.scale, {
                        x: 1,
                        y: 1,
                        z: 1,
                        duration: 0.3
                    });
                }
            }

            update(time) {
                // Floating animation
                this.mesh.position.y = this.config.height + Math.sin(time * 0.001 + this.index) * 0.3;
                if (this.aura) {
                    this.aura.position.y = this.mesh.position.y;
                }

                // Rotation
                this.mesh.rotation.y += 0.005;
                this.mesh.rotation.x = Math.sin(time * 0.0005) * 0.1;

                // Update shader uniforms
                this.mesh.material.uniforms.time.value = time * 0.001;
                this.mesh.material.uniforms.cameraPosition.value = camera.position;

                // Energy decay
                if (this.energy > 0) {
                    this.energy *= 0.98;
                    this.mesh.material.uniforms.emissiveIntensity.value = 0.2 + this.energy * 0.6;
                }

                // Update label
                this.updateLabelPosition();
            }
        }

        // Voting Flow class for plasma stream visualization
        class VotingFlow {
            constructor(source, target, color) {
                this.source = source;
                this.target = target;
                this.color = color || new THREE.Color(0xF59E0B);
                this.active = false;
                this.mesh = null;
                this.particles = [];
                this.createFlow();
            }

            createFlow() {
                // Create tube geometry for the flow
                const curve = new THREE.CatmullRomCurve3([
                    this.source.mesh.position.clone(),
                    new THREE.Vector3(
                        (this.source.mesh.position.x + this.target.mesh.position.x) / 2,
                        Math.max(this.source.mesh.position.y, this.target.mesh.position.y) + 5,
                        (this.source.mesh.position.z + this.target.mesh.position.z) / 2
                    ),
                    this.target.mesh.position.clone()
                ]);

                const tubeGeometry = new THREE.TubeGeometry(curve, 32, 0.3, 8, false);
                
                // Custom shader material for plasma flow
                const flowMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        flowColor: { value: this.color },
                        time: { value: 0 },
                        opacity: { value: 0.0 },
                        pulseRate: { value: 5.0 }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform vec3 flowColor;
                        uniform float time;
                        uniform float opacity;
                        uniform float pulseRate;
                        varying vec2 vUv;
                        
                        void main() {
                            float pulse = sin(vUv.x * 20.0 - time * pulseRate) * 0.5 + 0.5;
                            vec3 color = flowColor * (0.5 + pulse * 0.5);
                            float alpha = opacity * pulse * (1.0 - vUv.x); // Fade towards target
                            gl_FragColor = vec4(color, alpha);
                        }
                    `,
                    transparent: true,
                    side: THREE.DoubleSide
                });

                this.mesh = new THREE.Mesh(tubeGeometry, flowMaterial);
                this.mesh.visible = false;
                scene.add(this.mesh);

                // Create particle trail
                if (quality !== 'low') {
                    this.createParticleTrail();
                }
            }

            createParticleTrail() {
                const particleCount = 20;
                for (let i = 0; i < particleCount; i++) {
                    const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                    const particleMaterial = new THREE.MeshBasicMaterial({
                        color: this.color,
                        transparent: true,
                        opacity: 0
                    });
                    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                    particle.visible = false;
                    scene.add(particle);
                    this.particles.push({
                        mesh: particle,
                        progress: i / particleCount,
                        speed: 0.5 + Math.random() * 0.5
                    });
                }
            }

            activate() {
                if (this.active) return;
                this.active = true;
                this.mesh.visible = true;
                
                // Animate flow opacity
                gsap.to(this.mesh.material.uniforms.opacity, {
                    value: 0.6,
                    duration: 0.5
                });

                // Show particles
                this.particles.forEach(p => {
                    p.mesh.visible = true;
                    gsap.to(p.mesh.material, {
                        opacity: 0.8,
                        duration: 0.3
                    });
                });

                // Play flow sound
                if (audioEnabled && synth) {
                    playFlowSound();
                }
            }

            deactivate() {
                this.active = false;
                
                gsap.to(this.mesh.material.uniforms.opacity, {
                    value: 0,
                    duration: 0.5,
                    onComplete: () => {
                        this.mesh.visible = false;
                    }
                });

                // Hide particles
                this.particles.forEach(p => {
                    gsap.to(p.mesh.material, {
                        opacity: 0,
                        duration: 0.3,
                        onComplete: () => {
                            p.mesh.visible = false;
                        }
                    });
                });
            }

            update(time) {
                if (!this.active) return;

                // Update shader time
                this.mesh.material.uniforms.time.value = time * 0.001;

                // Update particle positions along curve
                const curve = new THREE.CatmullRomCurve3([
                    this.source.mesh.position.clone(),
                    new THREE.Vector3(
                        (this.source.mesh.position.x + this.target.mesh.position.x) / 2,
                        Math.max(this.source.mesh.position.y, this.target.mesh.position.y) + 5,
                        (this.source.mesh.position.z + this.target.mesh.position.z) / 2
                    ),
                    this.target.mesh.position.clone()
                ]);

                this.particles.forEach(p => {
                    p.progress += p.speed * 0.01;
                    if (p.progress > 1) {
                        p.progress = 0;
                        // Pulse at target
                        if (this.target === votingCore) {
                            votingCore.mesh.material.uniforms.emissiveIntensity.value = 0.8;
                            setTimeout(() => {
                                votingCore.mesh.material.uniforms.emissiveIntensity.value = 0.3;
                            }, 100);
                        }
                    }
                    
                    const point = curve.getPoint(p.progress);
                    p.mesh.position.copy(point);
                    
                    // Scale based on progress
                    const scale = Math.sin(p.progress * Math.PI) * 0.5 + 0.5;
                    p.mesh.scale.setScalar(scale);
                });
            }
        }

        // Array to store all voting flows

        // Enhanced Voting Core class with consensus field
        class VotingCore {
            constructor() {
                this.mesh = null;
                this.rings = [];
                this.active = false;
                this.consensus = 0;
                this.consensusField = null;
                this.createCore();
                this.createConsensusField();
            }

            createCore() {
                // Central sphere with custom shader
                const geometry = new THREE.SphereGeometry(2, 32, 32);
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        color: { value: new THREE.Color(chamberConfig.center.color) },
                        time: { value: 0 },
                        opacity: { value: 1.0 },
                        emissiveIntensity: { value: 0.3 }
                    },
                    vertexShader: governanceVertexShader,
                    fragmentShader: governanceFragmentShader,
                    transparent: true
                });

                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.y = 5;
                this.mesh.castShadow = true;
                this.mesh.receiveShadow = true;
                scene.add(this.mesh);

                // Orbital rings
                for (let i = 0; i < 3; i++) {
                    const ringGeometry = new THREE.TorusGeometry(3 + i, 0.1, 16, 100);
                    const ringMaterial = new THREE.MeshBasicMaterial({
                        color: chamberConfig.center.color,
                        transparent: true,
                        opacity: 0.3
                    });
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.position.y = 5;
                    ring.rotation.x = Math.PI / 2 + (i * 0.2);
                    scene.add(ring);
                    this.rings.push(ring);
                }
            }

            update(time) {
                // Core pulsing
                const scale = 1 + Math.sin(time * 0.002) * 0.1;
                this.mesh.scale.set(scale, scale, scale);

                // Update shader uniforms
                this.mesh.material.uniforms.time.value = time * 0.001;
                this.mesh.material.uniforms.emissiveIntensity.value = 0.3 + this.consensus * 0.5;

                // Rotate rings
                this.rings.forEach((ring, i) => {
                    ring.rotation.z += 0.01 * (i + 1);
                    ring.rotation.y += 0.005 * (i + 1);
                });
                
                // Update consensus field
                if (this.consensusField && this.consensusField.visible) {
                    this.consensusField.material.uniforms.time.value = time * 0.001;
                    this.consensusField.material.uniforms.cameraPosition.value = camera.position;
                    
                    // Gentle rotation
                    this.consensusField.rotation.y += 0.001;
                }
            }

            createConsensusField() {
                if (quality === 'low') return;
                
                // Create consensus field geometry
                const fieldGeometry = new THREE.SphereGeometry(20, 64, 64);
                
                // Consensus field shader material
                const fieldMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        primaryColor: { value: new THREE.Color(0x8B5CF6) },
                        secondaryColor: { value: new THREE.Color(0x3B82F6) },
                        tertiaryColor: { value: new THREE.Color(0x10B981) },
                        time: { value: 0 },
                        opacity: { value: 0.0 },
                        consensusLevel: { value: 0 },
                        cameraPosition: { value: camera.position },
                        fieldCenter: { value: new THREE.Vector3(0, 5, 0) },
                        fieldRadius: { value: 20 }
                    },
                    vertexShader: `
                        uniform float time;
                        uniform float consensusLevel;
                        
                        varying vec2 vUv;
                        varying vec3 vNormal;
                        varying vec3 vWorldPosition;
                        
                        void main() {
                            vUv = uv;
                            vNormal = normalize(normalMatrix * normal);
                            
                            vec3 pos = position;
                            float wave = sin(length(position.xz) * 0.5 - time * 2.0) * consensusLevel * 0.5;
                            pos += normal * wave;
                            
                            vec4 worldPosition = modelMatrix * vec4(pos, 1.0);
                            vWorldPosition = worldPosition.xyz;
                            
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform vec3 primaryColor;
                        uniform vec3 secondaryColor;
                        uniform vec3 tertiaryColor;
                        uniform float time;
                        uniform float opacity;
                        uniform float consensusLevel;
                        
                        varying vec2 vUv;
                        varying vec3 vNormal;
                        varying vec3 vWorldPosition;
                        
                        void main() {
                            vec3 viewDirection = normalize(cameraPosition - vWorldPosition);
                            float fresnel = pow(1.0 - abs(dot(viewDirection, vNormal)), 2.0);
                            
                            // Radial gradient
                            float radius = length(vWorldPosition.xz);
                            float gradient = smoothstep(5.0, 20.0, radius);
                            
                            vec3 color = mix(primaryColor, tertiaryColor, gradient);
                            
                            // Energy waves
                            float wave = sin(radius * 0.5 - time * 3.0) * 0.5 + 0.5;
                            color *= 0.5 + wave * 0.5 * consensusLevel;
                            
                            // Fresnel glow
                            color += (primaryColor + secondaryColor) * fresnel * 0.5 * consensusLevel;
                            
                            float alpha = opacity * fresnel * consensusLevel;
                            gl_FragColor = vec4(color, alpha);
                        }
                    `,
                    transparent: true,
                    side: THREE.BackSide,
                    depthWrite: false
                });
                
                this.consensusField = new THREE.Mesh(fieldGeometry, fieldMaterial);
                this.consensusField.position.y = 5;
                this.consensusField.visible = false;
                scene.add(this.consensusField);
            }

            showConsensus(level) {
                this.consensus = level;
                
                // Animate rings expanding
                this.rings.forEach((ring, i) => {
                    gsap.to(ring.scale, {
                        x: 1 + level * 0.5,
                        y: 1 + level * 0.5,
                        z: 1 + level * 0.5,
                        duration: 1,
                        delay: i * 0.1,
                        ease: "power2.out"
                    });
                });

                // Show consensus field
                if (this.consensusField && level > 0.3) {
                    this.consensusField.visible = true;
                    this.consensusField.material.uniforms.consensusLevel.value = level;
                    
                    gsap.to(this.consensusField.material.uniforms.opacity, {
                        value: 0.3 * level,
                        duration: 1
                    });
                    
                    gsap.to(this.consensusField.scale, {
                        x: 0.5 + level * 0.5,
                        y: 0.5 + level * 0.5,
                        z: 0.5 + level * 0.5,
                        duration: 2,
                        ease: "power2.out"
                    });
                }

                // Play consensus sound
                if (audioEnabled && synth) {
                    playConsensusSound(level);
                }
            }
        }

        // Initialize Three.js
        function initThree() {
            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.01);

            // Camera
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 15, 25); // Start within bounds
            camera.lookAt(0, 5, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('governance-canvas'),
                antialias: quality === 'high' || quality === 'ultra',
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, quality === 'ultra' ? 2 : 1.5));
            renderer.shadowMap.enabled = quality !== 'low';
            renderer.shadowMap.type = quality === 'low' ? THREE.BasicShadowMap : THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;

            // Raycaster and mouse
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Add lights
            setupLighting();

            // Create governance chamber
            createGovernanceChamber();

            // Create particle systems
            if (document.getElementById('showParticles').checked) {
                createEnergyParticles();
            }

            // Setup camera controls
            setupCameraControls();

            // Start animation
            animate();
        }

        // Setup lighting
        function setupLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            // Main light from above
            const mainLight = new THREE.DirectionalLight(0x10B981, 1);
            mainLight.position.set(0, 30, 0);
            mainLight.castShadow = quality !== 'low';
            if (mainLight.castShadow) {
                mainLight.shadow.mapSize.width = quality === 'ultra' ? 2048 : 1024;
                mainLight.shadow.mapSize.height = quality === 'ultra' ? 2048 : 1024;
                mainLight.shadow.camera.near = 0.5;
                mainLight.shadow.camera.far = 50;
                mainLight.shadow.camera.left = -30;
                mainLight.shadow.camera.right = 30;
                mainLight.shadow.camera.top = 30;
                mainLight.shadow.camera.bottom = -30;
            }
            scene.add(mainLight);

            // Accent lights for each tier
            if (quality !== 'low') {
                const councilLight = new THREE.PointLight(0x8B5CF6, 0.5, 20);
                councilLight.position.set(0, 15, 0);
                scene.add(councilLight);

                const committeeLight = new THREE.PointLight(0x3B82F6, 0.5, 25);
                committeeLight.position.set(0, 8, 0);
                scene.add(committeeLight);

                const forumLight = new THREE.PointLight(0x10B981, 0.5, 30);
                forumLight.position.set(0, 2, 0);
                scene.add(forumLight);
            }
        }

        // Create governance chamber
        function createGovernanceChamber() {
            // Create floor
            const floorGeometry = new THREE.CircleGeometry(25, 64);
            const floorMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x0a0a0a,
                metalness: 0.9,
                roughness: 0.1,
                transparent: true,
                opacity: 0.8
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -1;
            floor.receiveShadow = true;
            scene.add(floor);

            // Create grid on floor
            const gridHelper = new THREE.GridHelper(50, 50, 0x10B981, 0x0a0a0a);
            gridHelper.position.y = -0.9;
            scene.add(gridHelper);

            // Create nodes for each tier
            chamberConfig.tiers.forEach((tierConfig, tierIndex) => {
                for (let i = 0; i < tierConfig.count; i++) {
                    new GovernanceNode(tierIndex, i, tierConfig);
                }
            });

            // Create voting core
            votingCore = new VotingCore();

            // Create connections if enabled
            if (document.getElementById('showConnections').checked) {
                createGovernanceConnections();
            }
        }

        // Create governance connections
        function createGovernanceConnections() {
            // Connect nodes within tiers
            governanceNodes.forEach((node, i) => {
                // Connect to adjacent nodes in same tier
                const sameTierNodes = governanceNodes.filter(n => n.tier === node.tier);
                const nodeIndex = sameTierNodes.indexOf(node);
                
                if (nodeIndex !== -1) {
                    // Connect to next node in tier (circular)
                    const nextIndex = (nodeIndex + 1) % sameTierNodes.length;
                    createConnection(node, sameTierNodes[nextIndex], 0.3);
                }
                
                // Connect to voting core
                if (node.tier === 0) { // Only Protocol Council connects directly
                    createConnectionToCore(node);
                }
                
                // Connect tiers
                if (node.tier < 2) {
                    // Connect to corresponding nodes in next tier
                    const lowerTierNodes = governanceNodes.filter(n => n.tier === node.tier + 1);
                    if (lowerTierNodes.length > 0) {
                        const targetIndex = Math.floor((node.index / node.config.count) * lowerTierNodes[0].config.count);
                        if (lowerTierNodes[targetIndex]) {
                            createConnection(node, lowerTierNodes[targetIndex], 0.2);
                        }
                    }
                }
            });
        }

        // Create connection between nodes
        function createConnection(node1, node2, opacity = 0.5) {
            const material = new THREE.LineBasicMaterial({
                color: 0x10B981,
                transparent: true,
                opacity: opacity,
                linewidth: 2
            });
            
            const points = [node1.mesh.position, node2.mesh.position];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, material);
            
            scene.add(line);
            connections.push({ line, node1, node2 });
        }

        // Create connection to voting core
        function createConnectionToCore(node) {
            const material = new THREE.LineBasicMaterial({
                color: node.config.color,
                transparent: true,
                opacity: 0.4,
                linewidth: 3
            });
            
            const points = [node.mesh.position, votingCore.mesh.position];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, material);
            
            scene.add(line);
            connections.push({ line, node1: node, node2: votingCore, isCore: true });
        }

        // Energy Particle System - Fixed to be less intrusive
        class EnergyParticleSystem {
            constructor() {
                // Drastically reduced particle count for less clutter
                this.particleCount = quality === 'ultra' ? 150 : quality === 'high' ? 100 : quality === 'medium' ? 75 : 50;
                this.particles = new THREE.BufferGeometry();
                this.positions = new Float32Array(this.particleCount * 3);
                this.colors = new Float32Array(this.particleCount * 3);
                this.sizes = new Float32Array(this.particleCount);
                this.velocities = [];
                
                this.init();
            }
            
            init() {
                for (let i = 0; i < this.particleCount; i++) {
                    // More tightly constrained position within chamber bounds
                    const tier = Math.floor(Math.random() * 3);
                    const tierRadius = [8, 12, 16][tier]; // Match tier radii
                    const radius = tierRadius + (Math.random() - 0.5) * 2; // Small variation
                    const angle = Math.random() * Math.PI * 2;
                    
                    this.positions[i * 3] = Math.cos(angle) * radius;
                    this.positions[i * 3 + 1] = [10, 5, 0][tier] + (Math.random() - 0.5) * 2; // Near tier heights
                    this.positions[i * 3 + 2] = Math.sin(angle) * radius;
                    
                    // Color based on height (tier)
                    const height = this.positions[i * 3 + 1];
                    let color;
                    if (height > 7) {
                        color = new THREE.Color(0x8B5CF6); // Protocol Council purple
                    } else if (height > 2) {
                        color = new THREE.Color(0x3B82F6); // Technical Committee blue
                    } else {
                        color = new THREE.Color(0x10B981); // Community Forum green
                    }
                    
                    this.colors[i * 3] = color.r;
                    this.colors[i * 3 + 1] = color.g;
                    this.colors[i * 3 + 2] = color.b;
                    
                    this.sizes[i] = Math.random() * 0.5 + 0.3;  // Even smaller particles
                    
                    // Velocity
                    this.velocities.push({
                        x: (Math.random() - 0.5) * 0.01,
                        y: (Math.random() - 0.5) * 0.01,
                        z: (Math.random() - 0.5) * 0.01,
                        angle: Math.random() * Math.PI * 2,
                        angleVel: (Math.random() - 0.5) * 0.005
                    });
                }
                
                this.particles.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));
                this.particles.setAttribute('color', new THREE.BufferAttribute(this.colors, 3));
                this.particles.setAttribute('size', new THREE.BufferAttribute(this.sizes, 1));
                
                const material = new THREE.PointsMaterial({
                    size: 0.5,  // Much smaller base size
                    vertexColors: true,
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    opacity: 0.2,  // Even lower opacity
                    sizeAttenuation: true
                });
                
                this.mesh = new THREE.Points(this.particles, material);
                scene.add(this.mesh);
            }
            
            update(time) {
                const positions = this.particles.attributes.position.array;
                
                for (let i = 0; i < this.particleCount; i++) {
                    const vel = this.velocities[i];
                    const i3 = i * 3;
                    
                    // Circular motion
                    vel.angle += vel.angleVel;
                    const radius = Math.sqrt(positions[i3] * positions[i3] + positions[i3 + 2] * positions[i3 + 2]);
                    
                    // Gentle motion
                    positions[i3] = Math.cos(vel.angle) * radius;
                    positions[i3 + 2] = Math.sin(vel.angle) * radius;
                    
                    // Vertical drift
                    positions[i3 + 1] += vel.y;
                    
                    // Boundary check - keep within chamber
                    if (positions[i3 + 1] > 12) {
                        positions[i3 + 1] = -2;
                    } else if (positions[i3 + 1] < -2) {
                        positions[i3 + 1] = 12;
                    }
                    
                    // Keep particles within their tier radius
                    const maxRadius = [10, 14, 18][Math.floor((positions[i3 + 1] + 2) / 5)];
                    if (radius > maxRadius) {
                        vel.angle += Math.PI;
                        positions[i3] *= 0.95;
                        positions[i3 + 2] *= 0.95;
                    } else if (radius < 3) {
                        vel.angle += Math.PI;
                    }
                }
                
                this.particles.attributes.position.needsUpdate = true;
            }
        }

        let particleSystem;

        function createEnergyParticles() {
            particleSystem = new EnergyParticleSystem();
            energyParticles.push(particleSystem);
        }

        // Audio System
        function initAudio() {
            try {
                synth = new Tone.PolySynth(Tone.Synth).toDestination();
                synth.set({
                    oscillator: { type: "sine" },
                    envelope: {
                        attack: 0.02,
                        decay: 0.1,
                        sustain: 0.3,
                        release: 1
                    }
                });

                reverb = new Tone.Reverb(4).toDestination();
                panner = new Tone.Panner3D().toDestination();
                
                synth.connect(reverb);
                synth.connect(panner);
            } catch (e) {
                console.log('Audio initialization skipped');
            }
        }

        function playNodeSound(tier) {
            if (!audioEnabled || !synth) return;
            
            const notes = [
                ['C3', 'E3', 'G3', 'B3'],    // Protocol Council - low majestic
                ['G3', 'B3', 'D4', 'F#4'],   // Technical Committee - mid harmony
                ['C4', 'E4', 'G4', 'C5']     // Community Forum - high bright
            ];
            
            try {
                synth.triggerAttackRelease(notes[tier], '8n');
            } catch (e) {
                console.log('Audio playback skipped');
            }
        }

        function playFlowSound() {
            if (!audioEnabled || !synth) return;
            
            try {
                synth.triggerAttackRelease(['E4', 'G#4', 'B4'], '16n');
            } catch (e) {
                console.log('Audio playback skipped');
            }
        }

        function playConsensusSound(level) {
            if (!audioEnabled || !synth) return;
            
            // Build chord based on consensus level
            const baseNotes = ['C3', 'G3', 'C4', 'E4', 'G4'];
            const noteCount = Math.floor(level * baseNotes.length);
            const chord = baseNotes.slice(0, noteCount + 1);
            
            try {
                synth.triggerAttackRelease(chord, '2n');
            } catch (e) {
                console.log('Audio playback skipped');
            }
        }

        // Camera Controls
        function setupCameraControls() {
            let isMouseDown = false;
            let mouseX = 0;
            let mouseY = 0;
            let targetRotationX = 0;
            let targetRotationY = 0;

            document.addEventListener('mousedown', (e) => {
                if (e.target.tagName === 'CANVAS') {
                    isMouseDown = true;
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                }
            });

            document.addEventListener('mouseup', () => {
                isMouseDown = false;
            });

            document.addEventListener('mousemove', (e) => {
                if (isMouseDown && currentView !== 'cinematic') {
                    const deltaX = e.clientX - mouseX;
                    const deltaY = e.clientY - mouseY;
                    targetRotationY += deltaX * 0.01;
                    targetRotationX += deltaY * 0.01;
                    targetRotationX = Math.max(-Math.PI/4, Math.min(Math.PI/4, targetRotationX));
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                }

                // Update mouse position for raycasting
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

                // Update custom cursor
                const cursor = document.getElementById('customCursor');
                if (cursor) {
                    cursor.style.left = e.clientX + 'px';
                    cursor.style.top = e.clientY + 'px';
                }
            });

            // Mouse wheel zoom - Fixed constraints
            document.addEventListener('wheel', (e) => {
                if (e.target.closest('.control-panel') || e.target.closest('.view-modes')) return;
                if (currentView !== 'cinematic') {
                    e.preventDefault();
                    const zoomSpeed = 0.1; // Increased zoom speed
                    const distance = camera.position.length();
                    const zoomFactor = 1 + (e.deltaY > 0 ? zoomSpeed : -zoomSpeed);
                    const newDistance = distance * zoomFactor;
                    
                    // Wider zoom range for better usability
                    if (newDistance >= 10 && newDistance <= 60) {
                        const scaleFactor = newDistance / distance;
                        camera.position.x *= scaleFactor;
                        camera.position.y *= scaleFactor;
                        camera.position.z *= scaleFactor;
                        camera.lookAt(0, 5, 0);
                    }
                }
            }, { passive: false });

            // Smooth camera rotation with constraints
            function updateCameraRotation() {
                if (currentView === 'cinematic') return;
                
                const cameraDistance = camera.position.length();
                // Clamp camera distance to prevent it from going too far
                const clampedDistance = Math.max(15, Math.min(45, cameraDistance));
                
                camera.position.x = Math.sin(targetRotationY) * Math.cos(targetRotationX) * clampedDistance;
                camera.position.y = Math.sin(targetRotationX) * clampedDistance + 10;
                camera.position.z = Math.cos(targetRotationY) * Math.cos(targetRotationX) * clampedDistance;
                camera.lookAt(0, 5, 0);
            }

            return updateCameraRotation;
        }

        let updateCameraRotation;

        // View Mode Management
        function setViewMode(mode) {
            currentView = mode;

            // Kill any active camera animations
            if (orbitAnimation) orbitAnimation.kill();
            if (councilAnimation) councilAnimation.kill();
            if (timelineAnimation) timelineAnimation.kill();
            if (matrixAnimation) matrixAnimation.kill();

            // Update UI
            document.querySelectorAll('.view-mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-mode="${mode}"]`).classList.add('active');

            switch (mode) {
                case 'council':
                    showCouncilView();
                    break;
                case 'flow':
                    showVotingFlow();
                    break;
                case 'network':
                    showNetworkView();
                    break;
                case 'timeline':
                    showTimelineView();
                    break;
                case 'cinematic':
                    startCinematicMode();
                    break;
            }
        }

        function showCouncilView() {
            cinematicActive = false;
            document.getElementById('cinematicUI').classList.remove('visible');
            
            gsap.to(camera.position, {
                x: 0,
                y: 15,
                z: 25, // Reduced from 30 to stay within bounds
                duration: 2,
                ease: "power2.inOut",
                onUpdate: () => camera.lookAt(0, 5, 0)
            });
        }

        function showVotingFlow() {
            cinematicActive = false;
            document.getElementById('cinematicUI').classList.remove('visible');
            
            // Focus on voting core and show energy flows
            gsap.to(camera.position, {
                x: 20,
                y: 10,
                z: 20,
                duration: 2,
                ease: "power2.inOut",
                onUpdate: () => camera.lookAt(votingCore.mesh.position)
            });
            
            // Activate some nodes to show flow
            setTimeout(() => initiateVotingDemo(), 1000);
        }

        function showNetworkView() {
            cinematicActive = false;
            document.getElementById('cinematicUI').classList.remove('visible');
            
            // Top-down view - constrained height
            gsap.to(camera.position, {
                x: 0,
                y: 35, // Reduced from 40 to stay within bounds
                z: 5,
                duration: 2,
                ease: "power2.inOut",
                onUpdate: () => camera.lookAt(0, 0, 0)
            });
        }

        function showTimelineView() {
            cinematicActive = false;
            document.getElementById('cinematicUI').classList.remove('visible');
            
            // Side view focusing on tiers - constrained distance
            gsap.to(camera.position, {
                x: 30, // Reduced from 35 to stay within bounds
                y: 10,
                z: 0,
                duration: 2,
                ease: "power2.inOut",
                onUpdate: () => camera.lookAt(0, 5, 0)
            });
        }

        function startCinematicMode() {
            cinematicActive = true;
            document.getElementById('cinematicUI').classList.add('visible');
            
            // Start with orbit camera
            setCameraPreset('orbit');
            
            // Cycle through different camera modes
            const cinematicSequence = [
                { mode: 'orbit', duration: 10000 },
                { mode: 'council', duration: 8000 },
                { mode: 'timeline', duration: 8000 },
                { mode: 'matrix', duration: 6000 }
            ];
            
            let currentIndex = 0;
            function nextCinematicMode() {
                if (!cinematicActive) return;
                
                const current = cinematicSequence[currentIndex];
                setCameraPreset(current.mode);
                
                currentIndex = (currentIndex + 1) % cinematicSequence.length;
                setTimeout(nextCinematicMode, current.duration);
            }
            
            setTimeout(() => nextCinematicMode(), cinematicSequence[0].duration);
        }

        // Camera Presets
        function setCameraPreset(preset) {
            switch (preset) {
                case 'orbit':
                    startOrbitCamera();
                    break;
                case 'council':
                    startCouncilCamera();
                    break;
                case 'timeline':
                    startTimelineCamera();
                    break;
                case 'matrix':
                    startMatrixView();
                    break;
            }
        }

        function startOrbitCamera() {
            const radius = 28; // Reduced from 35 to stay within bounds
            
            orbitAnimation = gsap.timeline({ repeat: -1 })
                .to(camera.position, {
                    duration: 30,
                    ease: "none",
                    onUpdate: function() {
                        const progress = this.progress();
                        const angle = progress * Math.PI * 2;
                        camera.position.x = Math.cos(angle) * radius;
                        camera.position.z = Math.sin(angle) * radius;
                        camera.position.y = 15 + Math.sin(angle * 2) * 5;
                        camera.lookAt(0, 5, 0);
                    }
                });
        }

        function startCouncilCamera() {
            // Focus on each tier
            councilAnimation = gsap.timeline({ repeat: -1 });
            
            chamberConfig.tiers.forEach((tier, index) => {
                councilAnimation.to(camera.position, {
                    x: 15,
                    y: tier.height + 10,
                    z: 15,
                    duration: 5,
                    ease: "power2.inOut",
                    onUpdate: () => camera.lookAt(0, tier.height, 0)
                });
            });
        }

        function startTimelineCamera() {
            timelineAnimation = gsap.timeline({ repeat: -1 })
                .to(camera.position, {
                    x: -30,
                    y: 5,
                    z: 0,
                    duration: 5,
                    ease: "power2.inOut"
                })
                .to(camera.position, {
                    x: 30,
                    y: 20,
                    z: 0,
                    duration: 10,
                    ease: "power2.inOut",
                    onUpdate: () => camera.lookAt(0, 5, 0)
                });
        }

        function startMatrixView() {
            gsap.to(camera.position, {
                x: 0,
                y: 40, // Reduced from 50 to stay within bounds
                z: 0,
                duration: 3,
                ease: "power2.out",
                onUpdate: () => camera.lookAt(0, 0, 0)
            });
        }

        // Governance Actions
        function createProposal() {
            // Activate random community member
            const communityNodes = governanceNodes.filter(n => n.tier === 2);
            const proposer = communityNodes[Math.floor(Math.random() * communityNodes.length)];
            proposer.activate();
            
            // Create proposal visualization
            const proposalGeometry = new THREE.OctahedronGeometry(0.5);
            const proposalMaterial = new THREE.MeshBasicMaterial({
                color: 0xF59E0B,
                transparent: true,
                opacity: 0.8
            });
            const proposal = new THREE.Mesh(proposalGeometry, proposalMaterial);
            proposal.position.copy(proposer.mesh.position);
            scene.add(proposal);
            
            // Animate proposal to voting core
            gsap.to(proposal.position, {
                x: votingCore.mesh.position.x,
                y: votingCore.mesh.position.y,
                z: votingCore.mesh.position.z,
                duration: 2,
                ease: "power2.inOut",
                onComplete: () => {
                    scene.remove(proposal);
                    votingCore.showConsensus(0.3);
                    stats.proposalCount++;
                    updateStats();
                }
            });
            
            // Update stats
            stats.energyFlow = 'Active';
            updateStats();
        }

        function initiateVotingDemo() {
            let voteCount = 0;
            let consensus = 0;
            
            // Random voting from all tiers
            const voteInterval = setInterval(() => {
                if (voteCount >= 20) {
                    clearInterval(voteInterval);
                    // Show final consensus
                    votingCore.showConsensus(consensus / 20);
                    stats.consensusLevel = Math.floor((consensus / 20) * 100);
                    stats.energyFlow = 'Normal';
                    updateStats();
                    return;
                }
                
                // Random node votes
                const voter = governanceNodes[Math.floor(Math.random() * governanceNodes.length)];
                voter.activate();
                
                // Create vote particle
                const voteGeometry = new THREE.SphereGeometry(0.3);
                const voteMaterial = new THREE.MeshBasicMaterial({
                    color: voter.config.color,
                    transparent: true,
                    opacity: 0.8
                });
                const vote = new THREE.Mesh(voteGeometry, voteMaterial);
                vote.position.copy(voter.mesh.position);
                scene.add(vote);
                
                // Animate to core
                gsap.to(vote.position, {
                    x: votingCore.mesh.position.x,
                    y: votingCore.mesh.position.y,
                    z: votingCore.mesh.position.z,
                    duration: 1,
                    ease: "power2.in",
                    onComplete: () => {
                        scene.remove(vote);
                        voter.deactivate();
                    }
                });
                
                voteCount++;
                consensus += Math.random() > 0.3 ? 1 : 0; // 70% positive votes
            }, 300);
        }

        function showConsensus() {
            // Activate all nodes briefly
            governanceNodes.forEach((node, i) => {
                setTimeout(() => {
                    node.activate();
                    setTimeout(() => node.deactivate(), 1000);
                }, i * 50);
            });
            
            // Show maximum consensus
            setTimeout(() => {
                votingCore.showConsensus(1.0);
                stats.consensusLevel = 100;
                updateStats();
            }, 1500);
        }

        function resetGovernance() {
            // Deactivate all nodes
            governanceNodes.forEach(node => node.deactivate());
            
            // Reset voting core
            votingCore.consensus = 0;
            votingCore.showConsensus(0);
            
            // Reset stats
            stats.proposalCount = 0;
            stats.consensusLevel = 0;
            stats.energyFlow = 'Normal';
            updateStats();
            
            // Reset camera
            showCouncilView();
        }

        // UI Functions
        function showInfoPanel(node) {
            const panel = document.getElementById('infoPanel');
            const content = document.getElementById('infoPanelContent');
            
            const descriptions = {
                0: `Protocol Council Member ${node.index + 1}: Highest governance body responsible for constitutional matters and major protocol decisions.`,
                1: `Technical Committee Member ${node.index + 1}: Responsible for protocol improvements, security updates, and technical standards.`,
                2: `Community Forum Member ${node.index + 1}: Open participation layer that proposes improvements and elects representatives.`
            };
            
            content.textContent = descriptions[node.tier] || 'Governance node';
            panel.classList.add('visible');
        }

        function hideInfoPanel() {
            document.getElementById('infoPanel').classList.remove('visible');
        }

        function updateStats() {
            document.getElementById('proposalCount').textContent = stats.proposalCount;
            document.getElementById('consensusLevel').textContent = stats.consensusLevel + '%';
            document.getElementById('nodeCount').textContent = stats.nodeCount;
            document.getElementById('energyFlow').textContent = stats.energyFlow;
        }

        // FPS Counter
        function updateFPS() {
            frameCount++;
            
            const now = performance.now();
            if (now - lastFpsUpdate >= fpsUpdateInterval) {
                const fps = Math.round((frameCount * 1000) / (now - lastFpsUpdate));
                stats.fps = fps;
                document.getElementById('fpsCounter').textContent = fps;
                
                frameCount = 0;
                lastFpsUpdate = now;
            }
        }

        // Animation Loop
        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now();
            
            // Update FPS
            updateFPS();

            // Update governance nodes
            governanceNodes.forEach(node => node.update(time));

            // Update voting core
            if (votingCore) {
                votingCore.update(time);
            }

            // Update particles
            if (particleSystem) {
                particleSystem.update(time);
            }

            // Update connections
            connections.forEach(conn => {
                if (conn.line && conn.node1.mesh && conn.node2.mesh) {
                    const positions = conn.line.geometry.attributes.position.array;
                    positions[0] = conn.node1.mesh.position.x;
                    positions[1] = conn.node1.mesh.position.y;
                    positions[2] = conn.node1.mesh.position.z;
                    
                    if (conn.isCore && conn.node2.mesh) {
                        positions[3] = conn.node2.mesh.position.x;
                        positions[4] = conn.node2.mesh.position.y;
                        positions[5] = conn.node2.mesh.position.z;
                    } else if (conn.node2.mesh) {
                        positions[3] = conn.node2.mesh.position.x;
                        positions[4] = conn.node2.mesh.position.y;
                        positions[5] = conn.node2.mesh.position.z;
                    }
                    
                    conn.line.geometry.attributes.position.needsUpdate = true;
                }
            });

            // Update camera
            if (updateCameraRotation && currentView !== 'cinematic') {
                updateCameraRotation();
            }

            // Raycasting for hover effects
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);

            // Reset cursor
            const cursor = document.getElementById('customCursor');
            if (cursor) {
                cursor.classList.remove('hover');
            }

            if (intersects.length > 0) {
                const object = intersects[0].object;
                if (object.userData.node) {
                    if (cursor) {
                        cursor.classList.add('hover');
                    }
                    showInfoPanel(object.userData.node);
                }
            } else {
                hideInfoPanel();
            }

            // Render
            renderer.render(scene, camera);
        }

        // Event Listeners
        function setupEventListeners() {
            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // View mode buttons
            document.querySelectorAll('.view-mode-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    setViewMode(e.target.dataset.mode);
                });
            });

            // Control buttons
            document.getElementById('createProposalBtn').addEventListener('click', createProposal);
            document.getElementById('initiateVoteBtn').addEventListener('click', initiateVotingDemo);
            document.getElementById('showConsensusBtn').addEventListener('click', showConsensus);
            document.getElementById('resetGovernanceBtn').addEventListener('click', resetGovernance);

            // Camera presets
            document.querySelectorAll('.camera-preset').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    setCameraPreset(e.target.dataset.camera);
                });
            });

            // Quality settings
            document.querySelectorAll('.quality-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.quality-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    quality = e.target.dataset.quality;
                    
                    // Update renderer settings
                    renderer.setPixelRatio(Math.min(window.devicePixelRatio, quality === 'ultra' ? 2 : 1.5));
                    renderer.shadowMap.enabled = quality !== 'low';
                    renderer.shadowMap.type = quality === 'low' ? THREE.BasicShadowMap : THREE.PCFSoftShadowMap;
                    
                    // Recreate particle system with new quality
                    if (particleSystem) {
                        scene.remove(particleSystem.mesh);
                        energyParticles = [];
                        createEnergyParticles();
                    }
                });
            });

            // Visualization toggles
            document.getElementById('showParticles').addEventListener('change', (e) => {
                if (e.target.checked) {
                    createEnergyParticles();
                } else if (particleSystem) {
                    scene.remove(particleSystem.mesh);
                    particleSystem = null;
                    energyParticles = [];
                }
            });

            document.getElementById('showConnections').addEventListener('change', (e) => {
                if (e.target.checked) {
                    createGovernanceConnections();
                } else {
                    connections.forEach(conn => {
                        if (conn.line) scene.remove(conn.line);
                    });
                    connections = [];
                }
            });

            // Label toggle button
            document.getElementById('labelToggle').addEventListener('click', (e) => {
                labelState = (labelState + 1) % 3;
                const button = e.target;
                
                // Update button text
                const states = ['Off', 'Full', 'Short'];
                button.textContent = `Node Labels: ${states[labelState]}`;
                
                // Update all labels
                governanceNodes.forEach(node => {
                    if (node.label) {
                        node.updateLabelPosition();
                    }
                });
            });

            // Audio controls
            const audioToggle = document.getElementById('audioToggle');
            const volumeSlider = document.getElementById('volumeSlider');

            audioToggle.addEventListener('click', async () => {
                if (!audioEnabled) {
                    if (typeof Tone !== 'undefined' && Tone.context.state === 'suspended') {
                        await Tone.start();
                    }
                    audioEnabled = true;
                    audioToggle.textContent = 'üîä';
                    audioToggle.classList.add('active');
                } else {
                    audioEnabled = false;
                    audioToggle.textContent = 'üîá';
                    audioToggle.classList.remove('active');
                }
            });

            volumeSlider.addEventListener('input', (e) => {
                const volume = e.target.value / 100;
                if (typeof Tone !== 'undefined') {
                    Tone.Destination.volume.value = Tone.gainToDb(volume);
                }
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (document.activeElement.tagName === 'INPUT') return;

                switch(e.key) {
                    case '1':
                        setViewMode('council');
                        break;
                    case '2':
                        setViewMode('flow');
                        break;
                    case '3':
                        setViewMode('network');
                        break;
                    case '4':
                        setViewMode('timeline');
                        break;
                    case '5':
                        setViewMode('cinematic');
                        break;
                    case 'p':
                    case 'P':
                        createProposal();
                        break;
                    case 'v':
                    case 'V':
                        initiateVotingDemo();
                        break;
                    case 'r':
                    case 'R':
                        resetGovernance();
                        break;
                    case 'm':
                    case 'M':
                        audioToggle.click();
                        break;
                    case 'f':
                    case 'F':
                        if (!e.ctrlKey && !e.metaKey) {
                            toggleFullscreen();
                        }
                        break;
                    case '?':
                        document.getElementById('helpOverlay').style.display = 'flex';
                        break;
                    case 'Escape':
                        if (cinematicActive) {
                            setViewMode('council');
                        }
                        if (document.getElementById('helpOverlay').style.display === 'flex') {
                            document.getElementById('helpOverlay').style.display = 'none';
                        }
                        break;
                }
            });
        }

        // Fullscreen toggle
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }

        // Loading Manager
        const loadingManager = new THREE.LoadingManager();
        let loadingProgress = 0;

        loadingManager.onProgress = (url, itemsLoaded, itemsTotal) => {
            loadingProgress = (itemsLoaded / itemsTotal) * 100;
            document.getElementById('loadingProgress').style.width = loadingProgress + '%';
        };

        loadingManager.onLoad = () => {
            setTimeout(() => {
                document.getElementById('loadingScreen').style.opacity = '0';
                setTimeout(() => {
                    document.getElementById('loadingScreen').style.display = 'none';
                    startExperience();
                }, 500);
            }, 500);
        };

        // Start experience
        function startExperience() {
            // Initialize audio
            initAudio();
            
            // Setup controls
            updateCameraRotation = setupCameraControls();
            
            // Setup event listeners
            setupEventListeners();
            
            // Start in council view
            setViewMode('council');
            
            // Update initial stats
            updateStats();
        }

        // Initialize when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            updateLoadingStatus('Loading governance systems...');
            initThree();
            
            // Simulate loading
            let progress = 0;
            const loadingInterval = setInterval(() => {
                progress += 20;
                document.getElementById('loadingProgress').style.width = progress + '%';
                
                if (progress >= 100) {
                    clearInterval(loadingInterval);
                    loadingManager.onLoad();
                }
            }, 100);
        });

        function updateLoadingStatus(status) {
            document.getElementById('loadingStatus').textContent = status;
        }

        // Hide cursor when leaving window
        document.addEventListener('mouseleave', () => {
            const cursor = document.getElementById('customCursor');
            if (cursor) cursor.style.display = 'none';
        });

        document.addEventListener('mouseenter', () => {
            const cursor = document.getElementById('customCursor');
            if (cursor) cursor.style.display = 'block';
        });
    </script>
    <!-- Oracle Documentation Button -->
    <a href="/oracle.html" class="oracle-button">Access The Oracle Documentation</a>

</body>
</html>