<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Protocol - Attestation Vault</title>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            overflow: hidden;
            background: #000;
            color: #fff;
        }
        
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, #0a0a1a 0%, #000000 100%);
        }
        
        /* Loading Screen */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 1s ease-out;
        }
        
        .loading-spinner {
            width: 80px;
            height: 80px;
            border: 3px solid rgba(249, 191, 35, 0.2);
            border-top-color: #f9bf23;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .loading-text {
            margin-top: 20px;
            font-size: 18px;
            color: #f9bf23;
            text-align: center;
        }
        
        .loading-progress {
            width: 300px;
            height: 4px;
            background: rgba(249, 191, 35, 0.2);
            border-radius: 2px;
            margin-top: 20px;
            overflow: hidden;
        }
        
        .loading-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #f9bf23, #3b82f6);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        /* HUD Interface */
        #hud {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        
        .hud-element {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(249, 191, 35, 0.3);
            border-radius: 8px;
            padding: 20px;
            backdrop-filter: blur(10px);
            pointer-events: auto;
            transition: all 0.3s ease;
        }
        
        #vault-stats {
            top: 80px;
            left: 20px;
            min-width: 250px;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .stat-label {
            color: rgba(255, 255, 255, 0.7);
        }
        
        .stat-value {
            color: #f9bf23;
            font-weight: 600;
            font-feature-settings: "tnum";
        }
        
        /* Controls Panel */
        #controls-panel {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            pointer-events: auto;
            z-index: 200;
        }
        
        .control-button {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(249, 191, 35, 0.3);
            color: #fff;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            backdrop-filter: blur(10px);
        }
        
        .control-button:hover {
            background: rgba(249, 191, 35, 0.1);
            border-color: #f9bf23;
            transform: translateY(-2px);
        }
        
        .control-button:active {
            transform: translateY(0);
        }
        
        /* Command Palette */
        #command-palette {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 600px;
            max-width: 90%;
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid rgba(249, 191, 35, 0.3);
            border-radius: 12px;
            padding: 0;
            display: none;
            z-index: 1000;
            backdrop-filter: blur(20px);
        }
        
        #command-palette.active {
            display: block;
            animation: fadeIn 0.2s ease-out;
        }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translate(-50%, -45%);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }
        
        #command-search {
            width: 100%;
            background: transparent;
            border: none;
            color: #fff;
            font-size: 18px;
            padding: 20px;
            outline: none;
            border-bottom: 1px solid rgba(249, 191, 35, 0.2);
        }
        
        .command-list {
            max-height: 400px;
            overflow-y: auto;
        }
        
        .command-item {
            padding: 15px 20px;
            cursor: pointer;
            transition: background 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .command-item:hover {
            background: rgba(249, 191, 35, 0.1);
        }
        
        .command-item.selected {
            background: rgba(249, 191, 35, 0.2);
        }
        
        .command-shortcut {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.5);
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 8px;
            border-radius: 4px;
        }
        
        /* Info Panel */
        #info-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(249, 191, 35, 0.3);
            border-radius: 8px;
            padding: 20px;
            backdrop-filter: blur(10px);
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            pointer-events: auto;
        }
        
        /* Performance Indicator */
        #performance-indicator {
            position: fixed;
            bottom: 20px;
            left: 20px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.5);
            font-family: monospace;
            display: none;
        }
        
        /* Mobile Adjustments */
        @media (max-width: 768px) {
            #vault-stats {
                top: 120px;
                left: 10px;
                padding: 15px;
                min-width: auto;
            }
            
            #controls-panel {
                flex-wrap: wrap;
                gap: 5px;
                padding: 0 10px;
            }
            
            .control-button {
                padding: 10px 16px;
                font-size: 12px;
            }
        }
        
        /* Visual effects */
        .glow {
            box-shadow: 0 0 20px rgba(249, 191, 35, 0.5);
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }
        
        .pulse {
            animation: pulse 2s ease-in-out infinite;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading-screen">
        <div class="loading-spinner"></div>
        <div class="loading-text">Initializing Attestation Vault</div>
        <div class="loading-progress">
            <div class="loading-progress-bar"></div>
        </div>
    </div>
    
    <!-- Main Canvas Container -->
    <div id="canvas-container" role="application" aria-label="Attestation Vault 3D Visualization"></div>
    
    <!-- HUD Interface -->
    <div id="hud">
        <!-- Control Panel -->
        <div id="controls-panel">
            <button class="control-button" id="generate-attestation" aria-label="Generate new attestation">
                Generate Attestation
            </button>
            <button class="control-button" id="toggle-view" aria-label="Toggle view mode">
                Toggle View
            </button>
            <button class="control-button" id="cinematic-mode" aria-label="Enter cinematic mode">
                Cinematic
            </button>
            <button class="control-button" id="toggle-audio" aria-label="Toggle audio">
                ðŸ”Š Audio
            </button>
        </div>
        
        <!-- Vault Statistics -->
        <div id="vault-stats" class="hud-element" role="region" aria-label="Vault Statistics">
            <h2 style="font-size: 16px; margin-bottom: 15px; color: #f9bf23;">Attestation Vault</h2>
            <div class="stat-row">
                <span class="stat-label">Current Epoch</span>
                <span class="stat-value" id="current-epoch">2,847,193</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Total Stored</span>
                <span class="stat-value" id="total-stored">12.4M</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Partners Online</span>
                <span class="stat-value" id="partners-online">47/50</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Verification Rate</span>
                <span class="stat-value" id="verification-rate">99.97%</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Network Health</span>
                <span class="stat-value" id="network-health" style="color: #22c55e;">Optimal</span>
            </div>
        </div>
    </div>
    
    <!-- Command Palette -->
    <div id="command-palette" role="dialog" aria-label="Command Palette">
        <input 
            type="text" 
            id="command-search" 
            placeholder="Type a command..." 
            autocomplete="off"
            aria-label="Search commands"
        >
        <div class="command-list" role="listbox">
            <div class="command-item" role="option" data-command="generate">
                <span>Generate New Attestation</span>
                <span class="command-shortcut">Space</span>
            </div>
            <div class="command-item" role="option" data-command="verify">
                <span>Toggle Verification View</span>
                <span class="command-shortcut">V</span>
            </div>
            <div class="command-item" role="option" data-command="time">
                <span>Time Navigation Mode</span>
                <span class="command-shortcut">T</span>
            </div>
            <div class="command-item" role="option" data-command="cinematic">
                <span>Cinematic Mode</span>
                <span class="command-shortcut">C</span>
            </div>
            <div class="command-item" role="option" data-command="quality">
                <span>Change Quality Settings</span>
                <span class="command-shortcut">Q</span>
            </div>
            <div class="command-item" role="option" data-command="stats">
                <span>Toggle Performance Stats</span>
                <span class="command-shortcut">P</span>
            </div>
            <div class="command-item" role="option" data-command="help">
                <span>Show Help</span>
                <span class="command-shortcut">?</span>
            </div>
        </div>
    </div>
    
    <!-- Info Panel -->
    <div id="info-panel">
        <div>Press <strong>Ctrl/Cmd + K</strong> for commands</div>
        <div>Use mouse to rotate â€¢ Scroll to zoom</div>
    </div>
    
    <!-- Performance Indicator -->
    <div id="performance-indicator" aria-hidden="true"></div>
    
    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
        <script>
        // Main application class
        class AttestationVault {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.composer = null;
                
                this.vaultMesh = null;
                this.merkleForest = [];
                this.signatureFlow = null;
                this.attestationRings = [];
                this.particleSystems = [];
                
                this.clock = new THREE.Clock();
                this.stats = {
                    currentEpoch: 2847193,
                    totalStored: 12400000,
                    partnersOnline: 47,
                    verificationRate: 99.97
                };
                
                this.audioContext = null;
                this.sounds = {};
                this.audioEnabled = false;
                
                this.init();
            }
            
            async init() {
                try {
                    // Show loading screen
                    this.updateLoadingProgress(0, 'Initializing WebGL...');
                    
                    // Setup Three.js
                    this.setupRenderer();
                    this.updateLoadingProgress(10, 'Creating scene...');
                    
                    this.setupScene();
                    this.updateLoadingProgress(20, 'Loading shaders...');
                    
                    // Create vault visualization
                    await this.createVault();
                    this.updateLoadingProgress(40, 'Generating merkle forest...');
                    
                    this.createMerkleForest();
                    this.updateLoadingProgress(50, 'Initializing particle systems...');
                    
                    this.createSignatureFlow();
                    this.updateLoadingProgress(60, 'Creating attestation rings...');
                    
                    this.createAttestationRings();
                    this.updateLoadingProgress(70, 'Setting up lighting...');
                    
                    this.setupLighting();
                    this.updateLoadingProgress(80, 'Configuring effects...');
                    
                    this.createBackgroundElements();
                    this.updateLoadingProgress(90, 'Initializing controls...');
                    
                    // Setup systems
                    await this.setupAudio();
                    this.setupControls();
                    this.setupEventListeners();
                    this.setupPerformanceMonitoring();
                    
                    this.updateLoadingProgress(100, 'Ready!');
                    
                    // Hide loading screen
                    setTimeout(() => {
                        const loadingScreen = document.getElementById('loading-screen');
                        loadingScreen.style.opacity = '0';
                        setTimeout(() => loadingScreen.style.display = 'none', 1000);
                    }, 500);
                    
                    // Start animation loop
                    this.animate();
                    
                    // Start background updates
                    this.startBackgroundUpdates();
                    
                } catch (error) {
                    console.error('Initialization failed:', error);
                    this.showError('Failed to initialize attestation vault');
                }
            }
            
            updateLoadingProgress(percent, text) {
                const progressBar = document.querySelector('.loading-progress-bar');
                const loadingText = document.querySelector('.loading-text');
                
                if (progressBar) progressBar.style.width = percent + '%';
                if (loadingText) loadingText.textContent = text;
            }
            
            setupRenderer() {
                this.canvas = document.createElement('canvas');
                const container = document.getElementById('canvas-container');
                container.appendChild(this.canvas);
                
                this.renderer = new THREE.WebGLRenderer({
                    canvas: this.canvas,
                    antialias: true,
                    alpha: true,
                    powerPreference: 'high-performance'
                });
                
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.outputEncoding = THREE.sRGBEncoding;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 0.8; // Reduced exposure
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            }
            
            setupScene() {
                // Scene
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x000511, 0.02);
                
                // Camera
                this.camera = new THREE.PerspectiveCamera(
                    60,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.camera.position.set(30, 20, 30);
                this.camera.lookAt(0, 0, 0);
            }
            
            async createVault() {
                // Create central vault structure
                const vaultGroup = new THREE.Group();
                
                // Main octahedron
                const vaultGeometry = new THREE.OctahedronGeometry(5, 2);
                
                // Custom shader material
                const vaultMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        uTime: { value: 0 },
                        uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                        uMouse: { value: new THREE.Vector2(0.5, 0.5) },
                        uColor1: { value: new THREE.Color(0xf9bf23) },
                        uColor2: { value: new THREE.Color(0x3b82f6) },
                        uColor3: { value: new THREE.Color(0x8b5cf6) },
                        uGlowIntensity: { value: 0.5 }
                    },
                    vertexShader: `
                        varying vec3 vNormal;
                        varying vec3 vPosition;
                        varying vec2 vUv;
                        uniform float uTime;
                        
                        void main() {
                            vNormal = normalize(normalMatrix * normal);
                            vPosition = position;
                            vUv = uv;
                            
                            vec3 pos = position;
                            pos *= 1.0 + sin(position.y * 2.0 + uTime) * 0.1;
                            
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float uTime;
                        uniform vec2 uResolution;
                        uniform vec2 uMouse;
                        uniform vec3 uColor1;
                        uniform vec3 uColor2;
                        uniform vec3 uColor3;
                        uniform float uGlowIntensity;
                        
                        varying vec3 vNormal;
                        varying vec3 vPosition;
                        varying vec2 vUv;
                        
                        vec3 hash3(vec3 p) {
                            p = vec3(dot(p, vec3(127.1, 311.7, 74.7)),
                                    dot(p, vec3(269.5, 183.3, 246.1)),
                                    dot(p, vec3(113.5, 271.9, 124.6)));
                            return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);
                        }
                        
                        float noise(vec3 p) {
                            vec3 i = floor(p);
                            vec3 f = fract(p);
                            f = f * f * (3.0 - 2.0 * f);
                            
                            return mix(mix(mix(dot(hash3(i + vec3(0,0,0)), f - vec3(0,0,0)),
                                             dot(hash3(i + vec3(1,0,0)), f - vec3(1,0,0)), f.x),
                                         mix(dot(hash3(i + vec3(0,1,0)), f - vec3(0,1,0)),
                                             dot(hash3(i + vec3(1,1,0)), f - vec3(1,1,0)), f.x), f.y),
                                     mix(mix(dot(hash3(i + vec3(0,0,1)), f - vec3(0,0,1)),
                                             dot(hash3(i + vec3(1,0,1)), f - vec3(1,0,1)), f.x),
                                         mix(dot(hash3(i + vec3(0,1,1)), f - vec3(0,1,1)),
                                             dot(hash3(i + vec3(1,1,1)), f - vec3(1,1,1)), f.x), f.y), f.z);
                        }
                        
                        void main() {
                            vec3 normal = normalize(vNormal);
                            vec3 viewDir = normalize(cameraPosition - vPosition);
                            
                            // Fresnel effect
                            float fresnel = pow(1.0 - dot(normal, viewDir), 2.0);
                            
                            // Animated noise
                            float n = noise(vPosition * 2.0 + uTime * 0.5) * 0.5 + 0.5;
                            
                            // Color gradient
                            vec3 color = mix(uColor1, uColor2, n);
                            color = mix(color, uColor3, fresnel);
                            
                            // Holographic effect
                            float stripe = sin(vPosition.y * 10.0 + uTime * 2.0) * 0.5 + 0.5;
                            color = mix(color, vec3(1.0), stripe * fresnel * 0.3);
                            
                            // Glow
                            color += fresnel * uGlowIntensity * uColor1;
                            
                            // Final color with reduced intensity
                            gl_FragColor = vec4(color * 0.8, 0.9 + fresnel * 0.1);
                        }
                    `,
                    transparent: true,
                    side: THREE.DoubleSide,
                    depthWrite: true
                });
                
                this.vaultMaterial = vaultMaterial;
                this.vaultMesh = new THREE.Mesh(vaultGeometry, vaultMaterial);
                vaultGroup.add(this.vaultMesh);
                
                // Add inner core
                const coreGeometry = new THREE.IcosahedronGeometry(2, 1);
                const coreMaterial = new THREE.MeshPhysicalMaterial({
                    color: 0xf9bf23,
                    emissive: 0xf9bf23,
                    emissiveIntensity: 0.2,
                    metalness: 0.8,
                    roughness: 0.2,
                    clearcoat: 1.0,
                    clearcoatRoughness: 0.1
                });
                const coreMesh = new THREE.Mesh(coreGeometry, coreMaterial);
                vaultGroup.add(coreMesh);
                
                // Add wireframe overlay
                const wireframeGeometry = new THREE.OctahedronGeometry(5.1, 2);
                const wireframeMaterial = new THREE.MeshBasicMaterial({
                    color: 0xf9bf23,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.1
                });
                const wireframeMesh = new THREE.Mesh(wireframeGeometry, wireframeMaterial);
                vaultGroup.add(wireframeMesh);
                
                this.scene.add(vaultGroup);
                this.vaultGroup = vaultGroup;
            }
            
            createMerkleForest() {
                const merkleGroup = new THREE.Group();
                
                // Create 8 merkle trees around the vault
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const radius = 15;
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;
                    
                    const tree = this.createMerkleTree(x, 0, z);
                    merkleGroup.add(tree);
                    this.merkleForest.push(tree);
                }
                
                this.scene.add(merkleGroup);
            }
            
            createMerkleTree(x, y, z) {
                const treeGroup = new THREE.Group();
                treeGroup.position.set(x, y, z);
                
                // Create branches using cylinders
                const branchMaterial = new THREE.MeshPhysicalMaterial({
                    color: 0x2a4858,
                    emissive: 0x3b82f6,
                    emissiveIntensity: 0.1,
                    metalness: 0.3,
                    roughness: 0.7,
                    transparent: true,
                    opacity: 0.8
                });
                
                const createBranch = (parent, level, position, scale) => {
                    if (level > 4) return;
                    
                    const height = 2 * scale;
                    const radius = 0.1 * scale;
                    
                    const geometry = new THREE.CylinderGeometry(radius * 0.8, radius, height, 8);
                    const branch = new THREE.Mesh(geometry, branchMaterial);
                    branch.position.copy(position);
                    
                    parent.add(branch);
                    
                    // Create child branches
                    if (level < 4) {
                        const branches = level < 2 ? 3 : 2;
                        for (let i = 0; i < branches; i++) {
                            const angle = (i / branches) * Math.PI * 2;
                            const newPos = position.clone();
                            newPos.y += height * 0.8;
                            newPos.x += Math.cos(angle) * scale * 0.5;
                            newPos.z += Math.sin(angle) * scale * 0.5;
                            
                            createBranch(parent, level + 1, newPos, scale * 0.7);
                        }
                    }
                    
                    // Add data nodes at branch tips
                    if (level === 4) {
                        const nodeGeometry = new THREE.SphereGeometry(0.3, 8, 6);
                        const nodeMaterial = new THREE.MeshStandardMaterial({
							color: 0xf9bf23,
							emissive: 0xf9bf23,
							emissiveIntensity: 0.5,
							transparent: true,
							opacity: 0.8
						});
                        const node = new THREE.Mesh(nodeGeometry, nodeMaterial);
                        node.position.copy(position);
                        node.position.y += height * 0.5;
                        parent.add(node);
                    }
                };
                
                // Start tree generation
                createBranch(treeGroup, 0, new THREE.Vector3(0, 0, 0), 1);
                
                return treeGroup;
            }
            
            createSignatureFlow() {
                // Particle system for signature flows
                const particleCount = 2000;
                const geometry = new THREE.BufferGeometry();
                
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                const sizes = new Float32Array(particleCount);
                const alphas = new Float32Array(particleCount);
                
                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;
                    
                    // Create paths from merkle trees to vault
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 15 + Math.random() * 5;
                    const height = Math.random() * 10;
                    
                    positions[i3] = Math.cos(angle) * radius;
                    positions[i3 + 1] = height;
                    positions[i3 + 2] = Math.sin(angle) * radius;
                    
                    // Color gradient
                    const t = i / particleCount;
                    colors[i3] = 0.98 * (1 - t) + 0.23 * t;
                    colors[i3 + 1] = 0.75 * (1 - t) + 0.51 * t;
                    colors[i3 + 2] = 0.14 * (1 - t) + 0.96 * t;
                    
                    sizes[i] = Math.random() * 3 + 1;
                    alphas[i] = Math.random();
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                geometry.setAttribute('alpha', new THREE.BufferAttribute(alphas, 1));
                
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        uTime: { value: 0 },
                        uPixelRatio: { value: this.renderer.getPixelRatio() }
                    },
                    vertexShader: `
                        attribute float size;
                        attribute float alpha;
                        
                        varying vec3 vColor;
                        varying float vAlpha;
                        
                        uniform float uTime;
                        uniform float uPixelRatio;
                        
                        void main() {
                            vColor = color;
                            vAlpha = alpha;
                            
                            vec3 pos = position;
                            
                            // Flow animation
                            float flowSpeed = 0.5;
                            float t = fract(uTime * flowSpeed + alpha);
                            
                            // Move towards center
                            pos = mix(position, vec3(0.0, 0.0, 0.0), t);
                            pos.y += sin(t * 3.14159) * 2.0;
                            
                            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                            gl_Position = projectionMatrix * mvPosition;
                            
                            gl_PointSize = size * 50.0 * uPixelRatio / -mvPosition.z;
                        }
                    `,
                    fragmentShader: `
                        varying vec3 vColor;
                        varying float vAlpha;
                        
                        void main() {
                            vec2 center = vec2(0.5);
                            float dist = distance(gl_PointCoord, center);
                            
                            if (dist > 0.5) discard;
                            
                            float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                            alpha *= vAlpha * 0.8;
                            
                            gl_FragColor = vec4(vColor, alpha);
                        }
                    `,
                    transparent: true,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending,
                    vertexColors: true
                });
                
                this.signatureFlow = new THREE.Points(geometry, material);
                this.scene.add(this.signatureFlow);
                this.particleSystems.push(this.signatureFlow);
            }
            
            createAttestationRings() {
                const ringGroup = new THREE.Group();
                
                // Create multiple rings at different heights
                for (let i = 0; i < 5; i++) {
                    const radius = 8 + i * 2;
                    const height = (i - 2) * 3;
                    
                    const ringGeometry = new THREE.TorusGeometry(radius, 0.2, 8, 32);
                    const ringMaterial = new THREE.MeshPhysicalMaterial({
                        color: i % 2 === 0 ? 0xf9bf23 : 0x3b82f6,
                        emissive: i % 2 === 0 ? 0xf9bf23 : 0x3b82f6,
                        emissiveIntensity: 0.3,
                        metalness: 0.8,
                        roughness: 0.2,
                        transparent: true,
                        opacity: 0.6
                    });
                    
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.position.y = height;
                    ring.rotation.x = Math.PI / 2 + (Math.random() - 0.5) * 0.2;
                    
                    ring.userData = {
                        rotationSpeed: (Math.random() - 0.5) * 0.01,
                        orbitSpeed: (Math.random() - 0.5) * 0.005,
                        originalY: height
                    };
                    
                    ringGroup.add(ring);
                    this.attestationRings.push(ring);
                }
                
                this.scene.add(ringGroup);
            }
            
            createBackgroundElements() {
                // Add starfield
                const starsGeometry = new THREE.BufferGeometry();
                const starCount = 5000;
                const starPositions = new Float32Array(starCount * 3);
                
                for (let i = 0; i < starCount * 3; i += 3) {
                    const radius = 100 + Math.random() * 300;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos((Math.random() * 2) - 1);
                    
                    starPositions[i] = radius * Math.sin(phi) * Math.cos(theta);
                    starPositions[i + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    starPositions[i + 2] = radius * Math.cos(phi);
                }
                
                starsGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
                
                const starsMaterial = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 0.5,
                    transparent: true,
                    opacity: 0.6,
                    sizeAttenuation: true
                });
                
                const stars = new THREE.Points(starsGeometry, starsMaterial);
                this.scene.add(stars);
                
                // Add grid floor
                const gridHelper = new THREE.GridHelper(100, 50, 0x1a1a2e, 0x0f0f1e);
                gridHelper.position.y = -10;
                this.scene.add(gridHelper);
            }
            
            setupLighting() {
                // Ambient light
                const ambientLight = new THREE.AmbientLight(0x0a0a1a, 0.4);
                this.scene.add(ambientLight);
                
                // Main directional light
                const mainLight = new THREE.DirectionalLight(0xffffff, 0.6);
                mainLight.position.set(20, 30, 20);
                mainLight.castShadow = true;
                mainLight.shadow.camera.left = -30;
                mainLight.shadow.camera.right = 30;
                mainLight.shadow.camera.top = 30;
                mainLight.shadow.camera.bottom = -30;
                mainLight.shadow.camera.near = 1;
                mainLight.shadow.camera.far = 100;
                mainLight.shadow.mapSize.width = 2048;
                mainLight.shadow.mapSize.height = 2048;
                this.scene.add(mainLight);
                
                // Colored rim lights
                const rimLight1 = new THREE.DirectionalLight(0x3b82f6, 0.3);
                rimLight1.position.set(-30, 20, -30);
                this.scene.add(rimLight1);
                
                const rimLight2 = new THREE.DirectionalLight(0xf9bf23, 0.3);
                rimLight2.position.set(30, 20, -30);
                this.scene.add(rimLight2);
                
                // Point light in vault
                const vaultLight = new THREE.PointLight(0xf9bf23, 0.5, 20);
                vaultLight.position.set(0, 0, 0);
                this.scene.add(vaultLight);
            }
            
            async setupAudio() {
                try {
                    // Initialize on first user interaction
                    const initAudio = async () => {
                        await Tone.start();
                        
                        // Ambient drone
                        const drone = new Tone.Synth({
                            oscillator: { type: 'sine' },
                            envelope: { attack: 2, decay: 1, sustain: 0.8, release: 4 }
                        }).toDestination();
                        
                        drone.volume.value = -25;
                        
                        // Store synths
                        this.sounds.drone = drone;
                        
                        // Attestation sound
                        this.sounds.attestation = new Tone.PolySynth(Tone.Synth, {
                            oscillator: { type: 'sawtooth' },
                            envelope: { attack: 0.05, decay: 0.2, sustain: 0.3, release: 1 }
                        }).toDestination();
                        
                        // Remove listener after init
                        document.removeEventListener('click', initAudio);
                        document.removeEventListener('touchstart', initAudio);
                    };
                    
                    // Wait for user interaction
                    document.addEventListener('click', initAudio, { once: true });
                    document.addEventListener('touchstart', initAudio, { once: true });
                    
                } catch (error) {
                    console.warn('Audio initialization failed:', error);
                }
            }
            
            setupControls() {
                // Basic mouse controls
                this.mouseX = 0;
                this.mouseY = 0;
                this.autoRotate = true;
                
                // Mouse move handler
                window.addEventListener('mousemove', (e) => {
                    this.mouseX = (e.clientX / window.innerWidth) * 2 - 1;
                    this.mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
                });
                
                // Mouse wheel for zoom
                window.addEventListener('wheel', (e) => {
                    const zoomSpeed = 0.1;
                    const direction = e.deltaY > 0 ? 1 : -1;
                    const currentDistance = this.camera.position.length();
                    const newDistance = Math.max(15, Math.min(80, currentDistance + direction * zoomSpeed * currentDistance));
                    this.camera.position.normalize().multiplyScalar(newDistance);
                });
                
                // Mouse drag for rotation
                let mouseDown = false;
                let mouseXOnMouseDown = 0;
                let targetRotationOnMouseDown = 0;
                let targetRotation = 0;
                
                this.canvas.addEventListener('mousedown', (e) => {
                    mouseDown = true;
                    mouseXOnMouseDown = e.clientX;
                    targetRotationOnMouseDown = targetRotation;
                    this.autoRotate = false;
                });
                
                window.addEventListener('mouseup', () => {
                    mouseDown = false;
                });
                
                window.addEventListener('mousemove', (e) => {
                    if (mouseDown) {
                        const deltaX = e.clientX - mouseXOnMouseDown;
                        targetRotation = targetRotationOnMouseDown + deltaX * 0.01;
                    }
                });
                
                this.targetRotation = targetRotation;
            }
            
            setupEventListeners() {
                // Window resize
                window.addEventListener('resize', () => this.handleResize());
                
                // Keyboard controls
                window.addEventListener('keydown', (e) => this.handleKeyPress(e));
                
                // Button controls
                document.getElementById('generate-attestation').addEventListener('click', () => {
                    this.generateAttestation();
                });
                
                document.getElementById('toggle-view').addEventListener('click', () => {
                    this.toggleView();
                });
                
                document.getElementById('cinematic-mode').addEventListener('click', () => {
                    this.startCinematicMode();
                });
                
                document.getElementById('toggle-audio').addEventListener('click', () => {
                    this.toggleAudio();
                });
                
                // Command palette
                const commandPalette = document.getElementById('command-palette');
                const commandSearch = document.getElementById('command-search');
                
                // Open command palette
                window.addEventListener('keydown', (e) => {
                    if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                        e.preventDefault();
                        commandPalette.classList.toggle('active');
                        if (commandPalette.classList.contains('active')) {
                            commandSearch.focus();
                            commandSearch.value = '';
                        }
                    }
                });
                
                // Close on escape
                window.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        commandPalette.classList.remove('active');
                    }
                });
                
                // Command execution
                document.querySelectorAll('.command-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const command = item.dataset.command;
                        this.executeCommand(command);
                        commandPalette.classList.remove('active');
                    });
                });
            }
            
            handleResize() {
                const width = window.innerWidth;
                const height = window.innerHeight;
                
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                
                this.renderer.setSize(width, height);
                
                // Update shader uniforms
                if (this.vaultMaterial) {
                    this.vaultMaterial.uniforms.uResolution.value.set(width, height);
                }
            }
            
            handleKeyPress(event) {
                switch (event.key.toLowerCase()) {
                    case ' ':
                        event.preventDefault();
                        this.generateAttestation();
                        break;
                    case 'v':
                        this.toggleView();
                        break;
                    case 'c':
                        this.startCinematicMode();
                        break;
                    case 'p':
                        this.togglePerformanceStats();
                        break;
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                        this.setViewPreset(parseInt(event.key));
                        break;
                }
            }
            
            executeCommand(command) {
                switch (command) {
                    case 'generate':
                        this.generateAttestation();
                        break;
                    case 'verify':
                        this.toggleView();
                        break;
                    case 'cinematic':
                        this.startCinematicMode();
                        break;
                    case 'stats':
                        this.togglePerformanceStats();
                        break;
                }
            }
            
            generateAttestation() {
                // Visual effect
                const burstCount = 100;
                const burstGeometry = new THREE.BufferGeometry();
                const burstPositions = new Float32Array(burstCount * 3);
                const burstColors = new Float32Array(burstCount * 3);
                const burstSizes = new Float32Array(burstCount);
                
                for (let i = 0; i < burstCount; i++) {
                    const i3 = i * 3;
                    
                    burstPositions[i3] = 0;
                    burstPositions[i3 + 1] = 0;
                    burstPositions[i3 + 2] = 0;
                    
                    burstColors[i3] = 0.98;
                    burstColors[i3 + 1] = 0.75;
                    burstColors[i3 + 2] = 0.14;
                    
                    burstSizes[i] = Math.random() * 5 + 2;
                }
                
                burstGeometry.setAttribute('position', new THREE.BufferAttribute(burstPositions, 3));
                burstGeometry.setAttribute('color', new THREE.BufferAttribute(burstColors, 3));
                burstGeometry.setAttribute('size', new THREE.BufferAttribute(burstSizes, 1));
                
                const burstMaterial = new THREE.PointsMaterial({
                    size: 3,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true
                });
                
                const burst = new THREE.Points(burstGeometry, burstMaterial);
                this.scene.add(burst);
                
                // Animate burst
                const startTime = Date.now();
                const animateBurst = () => {
                    const elapsed = (Date.now() - startTime) / 1000;
                    const positions = burst.geometry.attributes.position.array;
                    
                    for (let i = 0; i < burstCount; i++) {
                        const i3 = i * 3;
                        const speed = 20 + Math.random() * 20;
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.acos(Math.random() * 2 - 1);
                        
                        positions[i3] = Math.sin(phi) * Math.cos(theta) * speed * elapsed;
                        positions[i3 + 1] = Math.sin(phi) * Math.sin(theta) * speed * elapsed;
                        positions[i3 + 2] = Math.cos(phi) * speed * elapsed;
                    }
                    
                    burst.geometry.attributes.position.needsUpdate = true;
                    burst.material.opacity = Math.max(0, 1 - elapsed);
                    
                    if (elapsed < 2) {
                        requestAnimationFrame(animateBurst);
                    } else {
                        this.scene.remove(burst);
                        burstGeometry.dispose();
                        burstMaterial.dispose();
                    }
                };
                animateBurst();
                
                // Play sound
                if (this.sounds.attestation) {
                    const notes = ['C4', 'E4', 'G4', 'C5'];
                    notes.forEach((note, i) => {
                        this.sounds.attestation.triggerAttackRelease(note, '8n', `+${i * 0.1}`);
                    });
                }
                
                // Update stats
                this.stats.totalStored += 1;
                this.updateStats();
                
                // Flash vault
                if (this.vaultMaterial) {
                    gsap.to(this.vaultMaterial.uniforms.uGlowIntensity, {
                        value: 1.0,
                        duration: 0.2,
                        yoyo: true,
                        repeat: 1,
                        ease: "power2.inOut"
                    });
                }
            }
            
            toggleView() {
                this.currentView = this.currentView === 'default' ? 'technical' : 'default';
                
                if (this.currentView === 'technical') {
                    // Show more technical details
                    this.attestationRings.forEach(ring => {
                        ring.material.wireframe = true;
                    });
                } else {
                    // Normal view
                    this.attestationRings.forEach(ring => {
                        ring.material.wireframe = false;
                    });
                }
            }
            
            startCinematicMode() {
                if (this.cinematicMode) return;
                
                this.cinematicMode = true;
                this.autoRotate = false;
                
                // Define camera path
                const points = [
                    new THREE.Vector3(30, 20, 30),
                    new THREE.Vector3(0, 40, 0),
                    new THREE.Vector3(-30, 15, -30),
                    new THREE.Vector3(0, 10, 40),
                    new THREE.Vector3(30, 20, 30)
                ];
                
                const curve = new THREE.CatmullRomCurve3(points, true);
                
                const cinematicDuration = 30; // 30 seconds
                const startTime = Date.now();
                
                const animateCamera = () => {
                    if (!this.cinematicMode) return;
                    
                    const elapsed = (Date.now() - startTime) / 1000;
                    const t = (elapsed % cinematicDuration) / cinematicDuration;
                    
                    const position = curve.getPoint(t);
                    this.camera.position.copy(position);
                    this.camera.lookAt(0, 0, 0);
                    
                    requestAnimationFrame(animateCamera);
                };
                
                animateCamera();
            }
            
            toggleAudio() {
                this.audioEnabled = !this.audioEnabled;
                const btn = document.getElementById('toggle-audio');
                
                if (this.audioEnabled && this.sounds.drone) {
                    this.sounds.drone.triggerAttack('C1');
                    btn.textContent = 'ðŸ”Š Audio';
                } else if (this.sounds.drone) {
                    this.sounds.drone.triggerRelease();
                    btn.textContent = 'ðŸ”‡ Audio';
                }
            }
            
            togglePerformanceStats() {
                const indicator = document.getElementById('performance-indicator');
                if (this.showPerformanceStats) {
                    indicator.style.display = 'none';
                    this.showPerformanceStats = false;
                } else {
                    indicator.style.display = 'block';
                    this.showPerformanceStats = true;
                }
            }
            
            setViewPreset(preset) {
                const presets = {
                    1: { position: [30, 20, 30], target: [0, 0, 0] },
                    2: { position: [0, 50, 0], target: [0, 0, 0] },
                    3: { position: [50, 10, 0], target: [0, 0, 0] },
                    4: { position: [0, 20, -50], target: [0, 0, 0] },
                    5: { position: [20, 30, 20], target: [0, 5, 0] }
                };
                
                const config = presets[preset];
                if (!config) return;
                
                // Smooth transition
                gsap.to(this.camera.position, {
                    x: config.position[0],
                    y: config.position[1],
                    z: config.position[2],
                    duration: 2,
                    ease: 'power2.inOut',
                    onUpdate: () => {
                        this.camera.lookAt(...config.target);
                    }
                });
            }
            
            setupPerformanceMonitoring() {
                let lastTime = performance.now();
                let frames = 0;
                
                const updatePerformance = () => {
                    const now = performance.now();
                    frames++;
                    
                    if (now >= lastTime + 1000) {
                        const fps = Math.round((frames * 1000) / (now - lastTime));
                        const ms = Math.round((now - lastTime) / frames);
                        
                        if (this.showPerformanceStats) {
                            const info = this.renderer.info;
                            
                            document.getElementById('performance-indicator').innerHTML = `
                                FPS: ${fps} (${ms}ms)<br>
                                Calls: ${info.render.calls}<br>
                                Triangles: ${info.render.triangles}<br>
                                Points: ${info.render.points}
                            `;
                        }
                        
                        frames = 0;
                        lastTime = now;
                    }
                    
                    requestAnimationFrame(updatePerformance);
                };
                
                updatePerformance();
            }
            
            updateStats() {
                document.getElementById('current-epoch').textContent = 
                    this.stats.currentEpoch.toLocaleString();
                document.getElementById('total-stored').textContent = 
                    (this.stats.totalStored / 1000000).toFixed(1) + 'M';
                document.getElementById('partners-online').textContent = 
                    `${this.stats.partnersOnline}/50`;
                document.getElementById('verification-rate').textContent = 
                    this.stats.verificationRate.toFixed(2) + '%';
            }
            
            startBackgroundUpdates() {
                // Simulate real-time updates
                setInterval(() => {
                    this.stats.currentEpoch += Math.floor(Math.random() * 10) + 1;
                    this.stats.totalStored += Math.floor(Math.random() * 100);
                    this.updateStats();
                }, 5000);
                
                // Partner status updates
                setInterval(() => {
                    const change = Math.random() > 0.5 ? 1 : -1;
                    this.stats.partnersOnline = Math.max(40, Math.min(50, 
                        this.stats.partnersOnline + change));
                    this.updateStats();
                }, 10000);
            }
            
            showError(message) {
                const errorDiv = document.createElement('div');
                errorDiv.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(0, 0, 0, 0.9);
                    border: 1px solid #ff6b6b;
                    color: #fff;
                    padding: 30px;
                    border-radius: 12px;
                    text-align: center;
                    z-index: 2000;
                `;
                errorDiv.innerHTML = `
                    <h2 style="color: #ff6b6b; margin-bottom: 15px;">Error</h2>
                    <p>${message}</p>
                    <p style="margin-top: 20px; color: #888;">
                        Please check your browser console for more details.
                    </p>
                `;
                document.body.appendChild(errorDiv);
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                const deltaTime = this.clock.getDelta();
                const elapsedTime = this.clock.getElapsedTime();
                
                // Update controls
                if (this.controls && this.controls.enabled) {
                    this.controls.update();
                }
                
                // Update vault shader
                if (this.vaultMaterial) {
                    this.vaultMaterial.uniforms.uTime.value = elapsedTime;
                    this.vaultMaterial.uniforms.uMouse.value.x = this.mouseX;
                    this.vaultMaterial.uniforms.uMouse.value.y = this.mouseY;
                }
                
                // Rotate vault group
                if (this.vaultGroup) {
                    this.vaultGroup.rotation.y += deltaTime * 0.1;
                }
                
                // Update merkle trees
                this.merkleForest.forEach((tree, index) => {
                    // Gentle swaying motion
                    tree.rotation.z = Math.sin(elapsedTime * 0.5 + index) * 0.05;
                    tree.rotation.x = Math.cos(elapsedTime * 0.3 + index) * 0.03;
                });
                
                // Update signature flow
                if (this.signatureFlow) {
                    this.signatureFlow.material.uniforms.uTime.value = elapsedTime;
                }
                
                // Update attestation rings
                this.attestationRings.forEach((ring) => {
                    ring.rotation.z += ring.userData.rotationSpeed;
                    ring.rotation.y += ring.userData.orbitSpeed;
                    ring.position.y = ring.userData.originalY + Math.sin(elapsedTime + ring.userData.originalY) * 0.5;
                });
                
                // Render
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // Initialize application
        window.addEventListener('DOMContentLoaded', () => {
            new AttestationVault();
        });
    </script>
</body>
</html>