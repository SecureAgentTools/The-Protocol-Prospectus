<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Protocol - Ultimate Technical Architecture</title>
    
    <!-- Social Media Meta Tags - Operation: Social Signal Integrity -->
    <meta name="description" content="No blockchain. No gas fees. Just pure distributed systems engineering. See how we built the TCP/IP of autonomous agents.">
    
    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="The Protocol Technical Architecture - 1000x Faster Than Blockchain">
    <meta property="og:description" content="No blockchain. No gas fees. Just pure distributed systems engineering. See how we built the TCP/IP of autonomous agents.">
    <meta property="og:image" content="https://www.theprotocol.cloud/tech-preview.png">
    <meta property="og:url" content="https://www.theprotocol.cloud/technical-page.html">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="The Protocol">
    
    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="The Protocol Technical Architecture - 1000x Faster Than Blockchain">
    <meta name="twitter:description" content="No blockchain. No gas fees. Just pure distributed systems engineering. See how we built the TCP/IP of autonomous agents.">
    <meta name="twitter:image" content="https://www.theprotocol.cloud/tech-preview.png">
    <meta name="twitter:site" content="@theprotocol">
    
    <!-- Additional Meta Tags for Enhanced Sharing -->
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:image:alt" content="The Protocol Technical Architecture Visualization">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* CSS Variables */
        :root {
            --primary-glow: #3B82F6;
            --secondary-glow: #8B5CF6;
            --accent-glow: #10B981;
            --danger-glow: #EF4444;
            --warning-glow: #F59E0B;
            --bg-void: #000000;
            --bg-deep: #0a0a0a;
            --bg-dark: #0F172A;
            --bg-card: rgba(15, 23, 42, 0.6);
            --text-bright: #FFFFFF;
            --text-primary: #F8FAFC;
            --text-secondary: #94A3B8;
            --text-muted: #475569;
            --gradient-primary: linear-gradient(135deg, #3B82F6 0%, #8B5CF6 100%);
            --gradient-accent: linear-gradient(135deg, #10B981 0%, #3B82F6 100%);
            --gradient-danger: linear-gradient(135deg, #EF4444 0%, #8B5CF6 100%);
            --gradient-rainbow: linear-gradient(90deg, #3B82F6 0%, #8B5CF6 25%, #EC4899 50%, #F59E0B 75%, #10B981 100%);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            cursor: none;
        }

        /* Universal Navigation Header */
        .nav-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(10, 10, 10, 0.8);
            backdrop-filter: blur(20px) saturate(180%);
            border-bottom: 1px solid rgba(59, 130, 246, 0.2);
            z-index: 10000;
            pointer-events: auto;
            transition: all 0.3s ease;
        }

        .nav-header.scrolled {
            background: rgba(10, 10, 10, 0.95);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
        }

        .nav-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            height: 80px;
        }

        .nav-logo {
            font-size: 1.5rem;
            font-weight: 900;
            background: var(--gradient-primary);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-decoration: none;
            letter-spacing: -0.02em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .nav-logo:hover {
            transform: scale(1.05);
        }

        .nav-menu {
            display: flex;
            align-items: center;
            gap: 2.5rem;
            list-style: none;
        }

        .nav-link {
            color: var(--text-secondary);
            text-decoration: none;
            font-weight: 500;
            font-size: 0.95rem;
            letter-spacing: 0.01em;
            transition: all 0.3s ease;
            position: relative;
            cursor: pointer;
        }

        .nav-link::after {
            content: '';
            position: absolute;
            bottom: -5px;
            left: 0;
            width: 0;
            height: 2px;
            background: var(--gradient-primary);
            transition: width 0.3s ease;
        }

        .nav-link:hover {
            color: var(--text-bright);
        }

        .nav-link:hover::after {
            width: 100%;
        }

        .nav-link.nav-cta {
            background: var(--gradient-primary);
            color: var(--text-bright);
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .nav-link.nav-cta:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(59, 130, 246, 0.3);
        }

        .nav-link.nav-cta::after {
            display: none;
        }

        .nav-link.nav-dev-portal {
            background: var(--gradient-accent);
        }

        /* Dropdown Styles */
        .nav-dropdown {
            position: relative;
        }

        .nav-dropdown-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
        }

        .dropdown-arrow {
            transition: transform 0.3s ease;
        }

        .nav-dropdown:hover .dropdown-arrow {
            transform: rotate(180deg);
        }

        .nav-dropdown-menu {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            min-width: 220px;
            background: rgba(10, 10, 10, 0.98);
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 0.75rem;
            padding: 0.5rem 0;
            margin-top: 1rem;
            opacity: 0;
            visibility: hidden;
            transform: translateX(-50%) translateY(-10px);
            transition: all 0.3s ease;
            list-style: none;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .nav-dropdown:hover .nav-dropdown-menu {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(0);
        }

        .nav-dropdown-link {
            display: block;
            padding: 0.75rem 1.5rem;
            color: var(--text-secondary);
            text-decoration: none;
            font-weight: 500;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            white-space: nowrap;
            cursor: pointer;
        }

        .nav-dropdown-link:hover {
            color: var(--text-bright);
            background: rgba(59, 130, 246, 0.1);
        }

        /* Oracle Documentation Button */
        .oracle-access-btn {
            position: fixed;
            bottom: 3rem;
            left: 50%;
            transform: translateX(-50%);
            padding: 0.75rem 2rem;
            background: var(--gradient-accent);
            color: var(--text-bright);
            text-decoration: none;
            border-radius: 50px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            z-index: 1000;
        }

        .oracle-access-btn:hover {
            transform: translateX(-50%) translateY(-3px) scale(1.05);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.2);
        }

        /* Custom Cursor */
        .cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            border: 2px solid #fff;
            border-radius: 50%;
            pointer-events: none;
            z-index: 10000;
            transition: transform 0.1s ease;
            mix-blend-mode: difference;
        }

        .cursor-dot {
            position: fixed;
            width: 4px;
            height: 4px;
            background: #fff;
            border-radius: 50%;
            pointer-events: none;
            z-index: 10001;
            mix-blend-mode: difference;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* UI Overlay */
        .ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        /* Logo */
        .logo {
            position: fixed;
            top: 120px;
            left: 40px;
            font-size: 24px;
            font-weight: 900;
            letter-spacing: -1px;
            background: linear-gradient(135deg, #fff 0%, #3B82F6 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            pointer-events: auto;
            cursor: pointer;
            transition: transform 0.3s ease;
        }

        .logo:hover {
            transform: scale(1.05);
        }

        /* Internal Navigation */
        .internal-nav-menu {
            position: fixed;
            top: 120px;
            right: 40px;
            display: flex;
            gap: 30px;
            pointer-events: auto;
        }

        .internal-nav-link {
            color: rgba(255, 255, 255, 0.7);
            text-decoration: none;
            font-weight: 500;
            transition: all 0.3s ease;
            position: relative;
            cursor: pointer;
        }

        .internal-nav-link:hover {
            color: #fff;
        }

        .internal-nav-link.active {
            color: #3B82F6;
        }

        .internal-nav-link::after {
            content: '';
            position: absolute;
            bottom: -5px;
            left: 0;
            width: 0;
            height: 2px;
            background: #3B82F6;
            transition: width 0.3s ease;
        }

        .internal-nav-link:hover::after, .internal-nav-link.active::after {
            width: 100%;
        }

        /* Performance Toggle */
        .performance-toggle {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            padding: 5px;
            border-radius: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            pointer-events: auto;
        }

        .perf-btn {
            padding: 8px 16px;
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            border-radius: 20px;
            transition: all 0.3s ease;
        }

        .perf-btn:hover {
            color: #fff;
        }

        .perf-btn.active {
            background: #3B82F6;
            color: #fff;
        }

        /* Title Section */
        .title-section {
            position: fixed;
            bottom: 100px;
            left: 40px;
            max-width: 600px;
            pointer-events: auto;
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .title {
            font-size: clamp(48px, 6vw, 96px);
            font-weight: 900;
            line-height: 1;
            margin-bottom: 20px;
            background: linear-gradient(135deg, #fff 0%, #3B82F6 50%, #8B5CF6 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            background-size: 200% 200%;
            animation: gradientShift 4s ease infinite;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .subtitle {
            font-size: 18px;
            color: rgba(255, 255, 255, 0.6);
            line-height: 1.6;
            margin-bottom: 30px;
        }

        /* Controls */
        .controls {
            position: fixed;
            bottom: 40px;
            right: 40px;
            display: flex;
            gap: 15px;
            pointer-events: auto;
        }

        .control-btn {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .control-btn.active {
            background: #3B82F6;
            border-color: #3B82F6;
        }

        /* Performance Stats */
        .stats {
            position: fixed;
            top: 180px;
            right: 40px;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-family: monospace;
            font-size: 12px;
            pointer-events: auto;
            min-width: 200px;
            transition: all 0.3s ease;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            color: rgba(255, 255, 255, 0.8);
        }

        .stat-value {
            color: #3B82F6;
            font-weight: bold;
        }

        /* Loading Screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 1s ease;
        }

        .loading-text {
            font-size: 24px;
            font-weight: 300;
            margin-bottom: 30px;
            opacity: 0.8;
        }

        .loading-bar {
            width: 300px;
            height: 2px;
            background: rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }

        .loading-progress {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background: linear-gradient(90deg, transparent, #3B82F6, transparent);
            width: 50%;
            animation: loading 1.5s ease-in-out infinite;
        }

        @keyframes loading {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(300%); }
        }

        /* Interaction Hints */
        .hint {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 30px;
            border-radius: 30px;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            pointer-events: none;
            opacity: 0;
            animation: fadeInOut 5s ease;
        }

        @keyframes fadeInOut {
            0%, 100% { opacity: 0; }
            20%, 80% { opacity: 1; }
        }

        /* Section-specific UI elements */
        .section-info {
            position: fixed;
            top: 180px;
            left: 40px;
            max-width: 400px;
            opacity: 0;
            transform: translateX(-50px);
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: none;
        }

        .section-info.active {
            opacity: 1;
            transform: translateX(0);
        }

        .section-info h2 {
            font-size: 36px;
            font-weight: 700;
            margin-bottom: 15px;
            background: linear-gradient(135deg, #fff 0%, #3B82F6 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .section-info p {
            font-size: 16px;
            line-height: 1.6;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 20px;
        }

        /* Code editor styles for Developers section */
        .code-editor {
            position: fixed;
            left: 40px;
            top: 50%;
            transform: translateY(-50%);
            width: 400px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 10px;
            padding: 20px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 14px;
            color: #fff;
            opacity: 0;
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: auto;
        }

        .code-editor.active {
            opacity: 1;
        }

        .code-editor pre {
            margin: 0;
            color: #fff;
        }

        .code-line {
            margin: 2px 0;
            transition: all 0.3s ease;
        }

        .code-line:hover {
            background: rgba(59, 130, 246, 0.1);
            padding-left: 10px;
        }

        /* Architecture details panel */
        .architecture-panel {
            position: fixed;
            right: 40px;
            top: 50%;
            transform: translateY(-50%);
            width: 350px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 10px;
            padding: 25px;
            opacity: 0;
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: auto;
        }

        .architecture-panel.active {
            opacity: 1;
        }

        .component-detail {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .component-detail:last-child {
            border-bottom: none;
        }

        .component-detail h3 {
            font-size: 18px;
            margin-bottom: 10px;
            color: #3B82F6;
        }

        .component-detail p {
            font-size: 14px;
            line-height: 1.5;
            color: rgba(255, 255, 255, 0.7);
        }

        /* Stats display for Overview */
        .overview-stats {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 30px;
            opacity: 0;
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: none;
        }

        .overview-stats.active {
            opacity: 1;
        }

        .stat-card {
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            transform: translateY(50px);
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .stat-card.active {
            transform: translateY(0);
        }

        .stat-number {
            font-size: 48px;
            font-weight: 900;
            color: #3B82F6;
            margin-bottom: 10px;
        }

        .stat-label {
            font-size: 16px;
            color: rgba(255, 255, 255, 0.8);
        }
    </style>
</head>
<body>
    <!-- Universal Navigation Header -->
    <header class="nav-header">
        <div class="nav-container">
            <a href="/" class="nav-logo">The Protocol</a>
            <nav>
                <ul class="nav-menu">
                    <li class="nav-dropdown">
                        <a href="#" class="nav-link nav-dropdown-toggle">
                            Ecosystem
                            <svg class="dropdown-arrow" width="12" height="8" viewBox="0 0 12 8" fill="currentColor">
                                <path d="M1 1L6 6L11 1" stroke="currentColor" stroke-width="2" fill="none"/>
                            </svg>
                        </a>
                        <ul class="nav-dropdown-menu">
                            <li><a href="/technical-page.html" class="nav-dropdown-link">Technical Architecture</a></li>
                            <li><a href="/federation.html" class="nav-dropdown-link">Federation Model</a></li>
                            <li><a href="/zkp-page.html" class="nav-dropdown-link">Zero-Knowledge Proofs</a></li>
                            <li><a href="/attestation.html" class="nav-dropdown-link">Attestation Network</a></li>
                            <li><a href="/governance.html" class="nav-dropdown-link">Governance</a></li>
                        </ul>
                    </li>
                    <li><a href="/developers-page.html" class="nav-link">For Developers</a></li>
                    <li><a href="#" class="nav-link nav-dev-portal" style="background: var(--gradient-accent); padding: 0.75rem 1.5rem; border-radius: 0.5rem;">Developer Portal â†’</a></li>
                    <li><a href="#application" class="nav-link nav-cta">Join Beta</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <!-- Custom Cursor -->
    <div class="cursor"></div>
    <div class="cursor-dot"></div>

    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-text">Initializing Quantum Visualization Engine</div>
        <div class="loading-bar">
            <div class="loading-progress"></div>
        </div>
    </div>

    <!-- Canvas Container -->
    <div id="canvas-container"></div>

    <!-- UI Overlay -->
    <div class="ui-overlay">
        <!-- Oracle Documentation Button -->
        <a href="/oracle.html" class="oracle-access-btn">
            <span style="margin-right: 0.5rem;">ðŸ“–</span> Access The Oracle Documentation
        </a>

        <!-- Logo -->
        <div class="logo" id="logo">Technical Architecture</div>

        <!-- Internal Navigation -->
        <nav class="internal-nav-menu">
            <a href="#" class="internal-nav-link active" data-section="home">Home</a>
            <a href="#" class="internal-nav-link" data-section="overview">Overview</a>
            <a href="#" class="internal-nav-link" data-section="architecture">Architecture</a>
            <a href="#" class="internal-nav-link" data-section="developers">Developers</a>
            <a href="#" class="internal-nav-link" data-section="docs">Docs</a>
        </nav>
        
        <!-- Performance Toggle -->
        <div class="performance-toggle">
            <button class="perf-btn" id="perfLow">Eco</button>
            <button class="perf-btn active" id="perfMed">Balanced</button>
            <button class="perf-btn" id="perfHigh">Ultra</button>
        </div>

        <!-- Title Section (Home) -->
        <div class="title-section" id="homeSection">
            <h1 class="title">Sovereign Stack</h1>
            <p class="subtitle">Experience the future of distributed systems through an immersive quantum visualization of our revolutionary architecture.</p>
        </div>

        <!-- Section Info -->
        <div class="section-info" id="sectionInfo">
            <h2 id="sectionTitle"></h2>
            <p id="sectionDescription"></p>
        </div>

        <!-- Overview Stats -->
        <div class="overview-stats" id="overviewStats">
            <div class="stat-card">
                <div class="stat-number" id="statAgents">0</div>
                <div class="stat-label">Active Agents</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="statTransactions">0</div>
                <div class="stat-label">Transactions/sec</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="statNodes">0</div>
                <div class="stat-label">Network Nodes</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="statUptime">0%</div>
                <div class="stat-label">Uptime</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="statLatency">0ms</div>
                <div class="stat-label">Avg Latency</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="statThroughput">0</div>
                <div class="stat-label">GB/s Throughput</div>
            </div>
        </div>

        <!-- Architecture Panel -->
        <div class="architecture-panel" id="architecturePanel">
            <div class="component-detail">
                <h3>Identity Core</h3>
                <p>SPIFFE/SPIRE-based cryptographic identity system providing zero-trust security for all agents.</p>
            </div>
            <div class="component-detail">
                <h3>Federation Network</h3>
                <p>P2P mesh topology enabling sovereign registries to communicate without central authority.</p>
            </div>
            <div class="component-detail">
                <h3>ZKP Engine</h3>
                <p>Groth16 zero-knowledge proof system for privacy-preserving attestations and verifications.</p>
            </div>
        </div>

        <!-- Code Editor for Developers -->
        <div class="code-editor" id="codeEditor">
            <pre><code><span class="code-line" style="color: #8B5CF6;">// Initialize Protocol Agent</span>
<span class="code-line" style="color: #3B82F6;">const</span> agent = <span class="code-line" style="color: #3B82F6;">new</span> <span class="code-line" style="color: #F59E0B;">ProtocolAgent</span>({
  <span class="code-line" style="color: #10B981;">identity</span>: <span class="code-line" style="color: #EF4444;">'spiffe://protocol/agent/01'</span>,
  <span class="code-line" style="color: #10B981;">registry</span>: <span class="code-line" style="color: #EF4444;">'sovereign-1.protocol.network'</span>,
  <span class="code-line" style="color: #10B981;">capabilities</span>: [<span class="code-line" style="color: #EF4444;">'compute'</span>, <span class="code-line" style="color: #EF4444;">'storage'</span>, <span class="code-line" style="color: #EF4444;">'zkp'</span>]
});

<span class="code-line" style="color: #8B5CF6;">// Connect to federation</span>
<span class="code-line" style="color: #3B82F6;">await</span> agent.<span class="code-line" style="color: #F59E0B;">connect</span>();

<span class="code-line" style="color: #8B5CF6;">// Execute risk-aware operation</span>
<span class="code-line" style="color: #3B82F6;">const</span> result = <span class="code-line" style="color: #3B82F6;">await</span> agent.<span class="code-line" style="color: #F59E0B;">execute</span>({
  <span class="code-line" style="color: #10B981;">command</span>: <span class="code-line" style="color: #EF4444;">'process_data'</span>,
  <span class="code-line" style="color: #10B981;">riskLevel</span>: <span class="code-line" style="color: #06B6D4;">RiskLevel</span>.<span class="code-line" style="color: #10B981;">MEDIUM</span>,
  <span class="code-line" style="color: #10B981;">proof</span>: zkpProof
});</code></pre>
        </div>

        <!-- Performance Stats -->
        <div class="stats" id="stats">
            <div class="stat-item">
                <span>FPS</span>
                <span class="stat-value" id="fps">60</span>
            </div>
            <div class="stat-item">
                <span>Particles</span>
                <span class="stat-value" id="particles">50K</span>
            </div>
            <div class="stat-item">
                <span>Vertices</span>
                <span class="stat-value" id="vertices">2.5M</span>
            </div>
            <div class="stat-item">
                <span>Draw Calls</span>
                <span class="stat-value" id="drawCalls">142</span>
            </div>
        </div>

        <!-- Controls -->
        <div class="controls">
            <div class="control-btn active" id="autoRotate" title="Auto Rotate">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.3"/>
                </svg>
            </div>
            <div class="control-btn active" id="particlesBtn" title="Toggle Particles">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="1"/>
                    <circle cx="12" cy="5" r="1"/>
                    <circle cx="12" cy="19" r="1"/>
                    <circle cx="16.5" cy="7.5" r="1"/>
                    <circle cx="7.5" cy="7.5" r="1"/>
                    <circle cx="7.5" cy="16.5" r="1"/>
                    <circle cx="16.5" cy="16.5" r="1"/>
                </svg>
            </div>
            <div class="control-btn" id="sound" title="Toggle Sound">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/>
                    <path d="M15.54 8.46a5 5 0 0 1 0 7.07M19.07 4.93a10 10 0 0 1 0 14.14"/>
                </svg>
            </div>
        </div>

        <!-- Interaction Hint -->
        <div class="hint" id="hint">Click and drag to explore â€¢ Scroll to zoom â€¢ Double-click to focus</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Ultimate High-Fidelity Visualization Engine with Navigation
        class QuantumVisualization {
            constructor() {
                this.container = document.getElementById('canvas-container');
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                this.mouse = new THREE.Vector2();
                this.raycaster = new THREE.Raycaster();
                this.clock = new THREE.Clock();
                this.autoRotate = true;
                this.showParticles = true;
                this.soundEnabled = false;
                this.currentSection = 'home';
                
                this.init();
                this.animate();
                
                // Keyboard controls
                window.addEventListener('keydown', (e) => this.onKeyDown(e));
                
                // Touch support
                window.addEventListener('touchstart', (e) => this.onTouchStart(e), { passive: false });
                window.addEventListener('touchmove', (e) => this.onTouchMove(e), { passive: false });
                window.addEventListener('touchend', (e) => this.onTouchEnd(e));
            }
            
            onKeyDown(event) {
                switch(event.key) {
                    case ' ':
                        // Space bar - toggle auto rotate
                        this.autoRotate = !this.autoRotate;
                        document.getElementById('autoRotate').classList.toggle('active');
                        break;
                    case 'p':
                        // P - toggle particles
                        this.showParticles = !this.showParticles;
                        if (this.particleSystem) {
                            this.particleSystem.visible = this.showParticles;
                        }
                        document.getElementById('particlesBtn').classList.toggle('active');
                        break;
                    case 's':
                        // S - toggle sound
                        this.soundEnabled = !this.soundEnabled;
                        document.getElementById('sound').classList.toggle('active');
                        this.toggleSound();
                        break;
                    case 'r':
                        // R - reset camera
                        this.resetCamera();
                        break;
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                        // Number keys - focus on specific crystals
                        const crystalIndex = parseInt(event.key) - 1;
                        if (crystalIndex < this.crystals.length) {
                            this.focusOnCrystal(this.crystals[crystalIndex].mesh);
                        }
                        break;
                    case 'ArrowLeft':
                        this.navigateToPreviousSection();
                        break;
                    case 'ArrowRight':
                        this.navigateToNextSection();
                        break;
                }
            }
            
            onTouchStart(event) {
                if (event.touches.length === 1) {
                    this.isDragging = true;
                    this.previousMouseX = event.touches[0].clientX;
                    this.previousMouseY = event.touches[0].clientY;
                } else if (event.touches.length === 2) {
                    // Pinch to zoom
                    const dx = event.touches[0].clientX - event.touches[1].clientX;
                    const dy = event.touches[0].clientY - event.touches[1].clientY;
                    this.pinchDistance = Math.sqrt(dx * dx + dy * dy);
                }
                event.preventDefault();
            }
            
            onTouchMove(event) {
                if (event.touches.length === 1 && this.isDragging) {
                    const deltaX = event.touches[0].clientX - this.previousMouseX;
                    const deltaY = event.touches[0].clientY - this.previousMouseY;
                    
                    this.targetCameraAngle += deltaX * 0.01;
                    this.targetCameraHeight = Math.max(-20, Math.min(30, this.targetCameraHeight - deltaY * 0.1));
                    
                    this.previousMouseX = event.touches[0].clientX;
                    this.previousMouseY = event.touches[0].clientY;
                } else if (event.touches.length === 2 && this.pinchDistance) {
                    const dx = event.touches[0].clientX - event.touches[1].clientX;
                    const dy = event.touches[0].clientY - event.touches[1].clientY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const scale = distance / this.pinchDistance;
                    
                    this.targetCameraRadius = Math.max(20, Math.min(80, this.targetCameraRadius / scale));
                    this.pinchDistance = distance;
                }
                event.preventDefault();
            }
            
            onTouchEnd(event) {
                this.isDragging = false;
                this.pinchDistance = null;
            }

            init() {
                // Scene setup with fog for depth
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x000011, 0.015);

                // Camera with cinematic properties
                this.camera = new THREE.PerspectiveCamera(
                    45,
                    this.width / this.height,
                    0.1,
                    1000
                );
                this.camera.position.set(0, 10, 40);
                this.camera.lookAt(0, 0, 0);

                // Renderer with maximum quality settings
                this.renderer = new THREE.WebGLRenderer({
                    antialias: true,
                    alpha: false,
                    powerPreference: "high-performance"
                });
                this.renderer.setSize(this.width, this.height);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.2;
                this.renderer.outputEncoding = THREE.sRGBEncoding;
                this.container.appendChild(this.renderer.domElement);

                // Post-processing setup
                this.setupPostProcessing();

                // Lighting system
                this.setupLighting();

                // Create the main visualization
                this.createQuantumField();
                this.createCrystallineStructures();
                this.createEnergyFlows();
                this.createHolographicInterface();
                this.createParticleUniverse();

                // Setup controls and interactions
                this.setupControls();
                this.setupEventListeners();
                this.setupNavigation();

                // Audio context for sound-reactive features
                this.setupAudio();

                // Hide loading screen
                setTimeout(() => {
                    document.getElementById('loadingScreen').style.opacity = '0';
                    setTimeout(() => {
                        document.getElementById('loadingScreen').style.display = 'none';
                        this.startIntroAnimation();
                        
                        // Show controls hint
                        setTimeout(() => {
                            this.showHint('Click and drag to explore â€¢ Scroll to zoom â€¢ Double-click to focus');
                            
                            // Show keyboard hint after 5 seconds
                            setTimeout(() => {
                                this.showHint('Press SPACE to toggle rotation â€¢ P for particles â€¢ S for sound â€¢ 1-6 to focus crystals');
                            }, 5000);
                        }, 1000);
                    }, 1000);
                }, 2000);
            }
            
            setupNavigation() {
                // Navigation links
                const navLinks = document.querySelectorAll('.internal-nav-link');
                navLinks.forEach(link => {
                    link.addEventListener('click', (e) => {
                        e.preventDefault();
                        const section = link.dataset.section;
                        this.navigateToSection(section);
                    });
                });
                
                // Logo click to return to index page
                document.getElementById('logo').addEventListener('click', () => {
                    window.location.href = '/';
                });
            }
            
            navigateToSection(section) {
                if (section === this.currentSection) return;
                
                // Update nav state
                document.querySelectorAll('.internal-nav-link').forEach(link => {
                    link.classList.toggle('active', link.dataset.section === section);
                });
                
                // Start transition
                this.transitionToSection(section);
                this.currentSection = section;
            }
            
            transitionToSection(section) {
                // Create transition effect
                this.createTransitionEffect();
                
                // Hide current UI elements
                this.hideCurrentSectionUI();
                
                // Transition based on section
                setTimeout(() => {
                    switch(section) {
                        case 'home':
                            this.transitionToHome();
                            break;
                        case 'overview':
                            this.transitionToOverview();
                            break;
                        case 'architecture':
                            this.transitionToArchitecture();
                            break;
                        case 'developers':
                            this.transitionToDevelopers();
                            break;
                        case 'docs':
                            window.open('https://docs.theprotocol.network', '_blank');
                            this.navigateToSection('home');
                            break;
                    }
                }, 600);
            }
            
            createTransitionEffect() {
                // Create a sweeping transition effect
                const transitionGeometry = new THREE.SphereGeometry(100, 32, 32);
                const transitionMaterial = new THREE.MeshBasicMaterial({
                    color: 0x3B82F6,
                    transparent: true,
                    opacity: 0,
                    side: THREE.BackSide
                });
                
                const transition = new THREE.Mesh(transitionGeometry, transitionMaterial);
                transition.position.copy(this.camera.position);
                this.scene.add(transition);
                
                // Animate transition
                const startTime = this.clock.getElapsedTime();
                const animateTransition = () => {
                    const elapsed = this.clock.getElapsedTime() - startTime;
                    if (elapsed < 1.2) {
                        const progress = elapsed / 1.2;
                        if (progress < 0.5) {
                            // Fade in
                            transition.material.opacity = progress * 0.8;
                            transition.scale.setScalar(1 - progress * 0.5);
                        } else {
                            // Fade out
                            transition.material.opacity = (1 - progress) * 0.8;
                            transition.scale.setScalar(0.5 + (progress - 0.5) * 10);
                        }
                        requestAnimationFrame(animateTransition);
                    } else {
                        this.scene.remove(transition);
                        transition.geometry.dispose();
                        transition.material.dispose();
                    }
                };
                animateTransition();
                
                // Sound effect
                if (this.soundEnabled && this.transitionSound) {
                    this.transitionSound();
                }
            }
            
            hideCurrentSectionUI() {
                // Fade out current section elements
                document.getElementById('homeSection').style.opacity = '0';
                document.getElementById('homeSection').style.transform = 'translateY(50px)';
                document.getElementById('sectionInfo').classList.remove('active');
                document.getElementById('overviewStats').classList.remove('active');
                document.getElementById('architecturePanel').classList.remove('active');
                document.getElementById('codeEditor').classList.remove('active');
                
                // Hide stat cards
                document.querySelectorAll('.stat-card').forEach(card => {
                    card.classList.remove('active');
                });
            }
            
            transitionToHome() {
                // Reset to home view
                this.resetCamera();
                
                // Show home UI
                setTimeout(() => {
                    document.getElementById('homeSection').style.opacity = '1';
                    document.getElementById('homeSection').style.transform = 'translateY(0)';
                }, 300);
                
                // Reset crystal arrangements
                this.animateCrystalsToHome();
                
                // Set scene mood
                this.setSceneMood('default');
                
                this.showHint('Welcome back to The Protocol sovereign stack');
            }
            
            transitionToOverview() {
                // Camera to bird's eye view
                this.targetCameraRadius = 60;
                this.targetCameraHeight = 40;
                this.targetCameraAngle = Math.PI / 4;
                
                // Show section info
                const sectionInfo = document.getElementById('sectionInfo');
                document.getElementById('sectionTitle').textContent = 'System Overview';
                document.getElementById('sectionDescription').textContent = 'Real-time metrics and network statistics showcasing the power and scale of The Protocol ecosystem.';
                setTimeout(() => sectionInfo.classList.add('active'), 300);
                
                // Rearrange crystals into constellation
                this.animateCrystalsToConstellation();
                
                // Show stats with animation
                this.showOverviewStats();
                
                // Create data flow visualization
                this.createDataFlowVisualization();
                
                // Set scene mood
                this.setSceneMood('overview');
                
                this.showHint('Viewing system-wide metrics and performance indicators');
            }
            
            transitionToArchitecture() {
                // Focus on central architecture
                this.targetCameraRadius = 30;
                this.targetCameraHeight = 15;
                this.targetCameraAngle = 0;
                
                // Show section info
                const sectionInfo = document.getElementById('sectionInfo');
                document.getElementById('sectionTitle').textContent = 'Technical Architecture';
                document.getElementById('sectionDescription').textContent = 'Deep dive into the components that power The Protocol. Click on any crystal to explore its internals.';
                setTimeout(() => sectionInfo.classList.add('active'), 300);
                
                // Show architecture panel
                setTimeout(() => {
                    document.getElementById('architecturePanel').classList.add('active');
                }, 600);
                
                // Animate crystals to exploded view
                this.animateCrystalsToExploded();
                
                // Create technical overlays
                this.createTechnicalOverlays();
                
                // Set scene mood
                this.setSceneMood('technical');
                
                this.showHint('Click on components to view detailed specifications');
            }
            
            transitionToDevelopers() {
                // Workshop view
                this.targetCameraRadius = 35;
                this.targetCameraHeight = 10;
                this.targetCameraAngle = -Math.PI / 6;
                
                // Show section info
                const sectionInfo = document.getElementById('sectionInfo');
                document.getElementById('sectionTitle').textContent = 'Developer Workshop';
                document.getElementById('sectionDescription').textContent = 'Build with The Protocol. Interactive SDK visualization and live code examples.';
                setTimeout(() => sectionInfo.classList.add('active'), 300);
                
                // Show code editor
                setTimeout(() => {
                    document.getElementById('codeEditor').classList.add('active');
                    this.animateCodeTyping();
                }, 600);
                
                // Transform scene to workshop
                this.transformToWorkshop();
                
                // Set scene mood
                this.setSceneMood('developer');
                
                this.showHint('Explore our SDK and start building sovereign agents');
            }
            
            animateCrystalsToHome() {
                // Return crystals to original positions
                this.crystals.forEach((crystal, index) => {
                    const targetPos = crystal.originalPosition.clone();
                    this.animateCrystalPosition(crystal.mesh, targetPos, index * 100);
                });
            }
            
            animateCrystalsToConstellation() {
                // Arrange crystals in a network constellation
                const radius = 25;
                this.crystals.forEach((crystal, index) => {
                    const angle = (index / this.crystals.length) * Math.PI * 2;
                    const targetPos = new THREE.Vector3(
                        Math.cos(angle) * radius,
                        Math.sin(index * 0.5) * 5,
                        Math.sin(angle) * radius
                    );
                    this.animateCrystalPosition(crystal.mesh, targetPos, index * 100);
                });
                
                // Create constellation connections
                this.createConstellationConnections();
            }
            
            animateCrystalsToExploded() {
                // Exploded view for architecture
                this.crystals.forEach((crystal, index) => {
                    const scale = 2;
                    const targetPos = crystal.originalPosition.clone().multiplyScalar(scale);
                    targetPos.y *= 1.5;
                    this.animateCrystalPosition(crystal.mesh, targetPos, index * 150);
                    
                    // Scale up for better visibility
                    this.animateCrystalScale(crystal.mesh, 1.2, index * 150);
                });
            }
            
            transformToWorkshop() {
                // Arrange crystals as interactive workshop elements
                const positions = [
                    new THREE.Vector3(-15, 0, 0),  // API Endpoints
                    new THREE.Vector3(-5, 0, 0),   // SDK Core
                    new THREE.Vector3(5, 0, 0),    // Examples
                    new THREE.Vector3(15, 0, 0),   // Testing
                    new THREE.Vector3(0, 8, -10),  // Documentation
                    new THREE.Vector3(0, -5, -10)  // Resources
                ];
                
                this.crystals.forEach((crystal, index) => {
                    if (index < positions.length) {
                        this.animateCrystalPosition(crystal.mesh, positions[index], index * 100);
                    }
                });
                
                // Create workshop environment
                this.createWorkshopElements();
            }
            
            animateCrystalPosition(crystal, targetPos, delay) {
                setTimeout(() => {
                    const startPos = crystal.position.clone();
                    const startTime = this.clock.getElapsedTime();
                    
                    const animate = () => {
                        const elapsed = this.clock.getElapsedTime() - startTime;
                        const progress = Math.min(elapsed * 0.5, 1);
                        
                        // Smooth easing
                        const easeProgress = 1 - Math.pow(1 - progress, 3);
                        
                        crystal.position.lerpVectors(startPos, targetPos, easeProgress);
                        
                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        }
                    };
                    animate();
                }, delay);
            }
            
            animateCrystalScale(crystal, targetScale, delay) {
                setTimeout(() => {
                    const startScale = crystal.scale.x;
                    const startTime = this.clock.getElapsedTime();
                    
                    const animate = () => {
                        const elapsed = this.clock.getElapsedTime() - startTime;
                        const progress = Math.min(elapsed * 0.5, 1);
                        
                        const scale = startScale + (targetScale - startScale) * progress;
                        crystal.scale.setScalar(scale);
                        
                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        }
                    };
                    animate();
                }, delay);
            }
            
            showOverviewStats() {
                const stats = document.getElementById('overviewStats');
                stats.classList.add('active');
                
                // Animate stat cards
                const cards = stats.querySelectorAll('.stat-card');
                cards.forEach((card, index) => {
                    setTimeout(() => {
                        card.classList.add('active');
                    }, index * 100);
                });
                
                // Animate numbers
                this.animateStatNumbers();
            }
            
            animateStatNumbers() {
                // Animate stat numbers with realistic values
                this.animateNumber('statAgents', 0, 12847, 2000);
                this.animateNumber('statTransactions', 0, 3524, 2200);
                this.animateNumber('statNodes', 0, 847, 2400);
                this.animateNumber('statUptime', 0, 99.97, 2600, '%');
                this.animateNumber('statLatency', 0, 12, 2800, 'ms');
                this.animateNumber('statThroughput', 0, 24.7, 3000);
            }
            
            animateNumber(elementId, start, end, duration, suffix = '') {
                const element = document.getElementById(elementId);
                const startTime = Date.now();
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Easing function
                    const easeProgress = 1 - Math.pow(1 - progress, 3);
                    const current = start + (end - start) * easeProgress;
                    
                    // Format based on type
                    if (suffix === '%') {
                        element.textContent = current.toFixed(2) + suffix;
                    } else if (suffix === 'ms') {
                        element.textContent = Math.round(current) + suffix;
                    } else if (end < 100) {
                        element.textContent = current.toFixed(1);
                    } else {
                        element.textContent = Math.round(current).toLocaleString();
                    }
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    }
                };
                animate();
            }
            
            createDataFlowVisualization() {
                // Create flowing data particles between nodes
                if (!this.dataFlowParticles) {
                    const particleCount = 1000;
                    const geometry = new THREE.BufferGeometry();
                    const positions = new Float32Array(particleCount * 3);
                    const colors = new Float32Array(particleCount * 3);
                    
                    for (let i = 0; i < particleCount; i++) {
                        const i3 = i * 3;
                        positions[i3] = (Math.random() - 0.5) * 50;
                        positions[i3 + 1] = (Math.random() - 0.5) * 20;
                        positions[i3 + 2] = (Math.random() - 0.5) * 50;
                        
                        const color = new THREE.Color(0x00ffff);
                        colors[i3] = color.r;
                        colors[i3 + 1] = color.g;
                        colors[i3 + 2] = color.b;
                    }
                    
                    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                    
                    const material = new THREE.PointsMaterial({
                        size: 0.5,
                        vertexColors: true,
                        transparent: true,
                        opacity: 0.8,
                        blending: THREE.AdditiveBlending
                    });
                    
                    this.dataFlowParticles = new THREE.Points(geometry, material);
                    this.scene.add(this.dataFlowParticles);
                }
                
                this.dataFlowParticles.visible = true;
            }
            
            createConstellationConnections() {
                // Create dynamic connections between crystals
                if (!this.constellationLines) {
                    this.constellationLines = new THREE.Group();
                    this.scene.add(this.constellationLines);
                }
                
                // Clear existing lines
                while (this.constellationLines.children.length > 0) {
                    const child = this.constellationLines.children[0];
                    this.constellationLines.remove(child);
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                }
                
                // Create new connections
                for (let i = 0; i < this.crystals.length; i++) {
                    for (let j = i + 1; j < this.crystals.length; j++) {
                        if (Math.random() > 0.5) {
                            const geometry = new THREE.BufferGeometry().setFromPoints([
                                this.crystals[i].mesh.position,
                                this.crystals[j].mesh.position
                            ]);
                            
                            const material = new THREE.LineBasicMaterial({
                                color: 0x3B82F6,
                                transparent: true,
                                opacity: 0.3
                            });
                            
                            const line = new THREE.Line(geometry, material);
                            this.constellationLines.add(line);
                        }
                    }
                }
            }
            
            createTechnicalOverlays() {
                // Create holographic technical details for each crystal
                this.crystals.forEach((crystal, index) => {
                    const overlay = this.createTechnicalOverlay(crystal.data);
                    overlay.position.copy(crystal.mesh.position);
                    overlay.position.y += 5;
                    this.scene.add(overlay);
                    
                    // Store reference for cleanup
                    if (!this.technicalOverlays) this.technicalOverlays = [];
                    this.technicalOverlays.push(overlay);
                });
            }
            
            createTechnicalOverlay(data) {
                const group = new THREE.Group();
                
                // Create holographic panel
                const panelGeometry = new THREE.PlaneGeometry(6, 4);
                const panelMaterial = new THREE.MeshBasicMaterial({
                    color: data.color,
                    transparent: true,
                    opacity: 0.1,
                    side: THREE.DoubleSide
                });
                
                const panel = new THREE.Mesh(panelGeometry, panelMaterial);
                group.add(panel);
                
                // Add wireframe
                const wireframeGeometry = new THREE.EdgesGeometry(panelGeometry);
                const wireframeMaterial = new THREE.LineBasicMaterial({
                    color: data.color,
                    transparent: true,
                    opacity: 0.5
                });
                const wireframe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
                group.add(wireframe);
                
                return group;
            }
            
            createWorkshopElements() {
                // Create interactive workshop visualization elements
                if (!this.workshopElements) {
                    this.workshopElements = new THREE.Group();
                    this.scene.add(this.workshopElements);
                    
                    // Create code visualization particles
                    const codeParticles = this.createCodeParticles();
                    this.workshopElements.add(codeParticles);
                    
                    // Create API endpoint visualizations
                    const apiEndpoints = this.createAPIEndpoints();
                    this.workshopElements.add(apiEndpoints);
                }
                
                this.workshopElements.visible = true;
            }
            
            createCodeParticles() {
                // Create floating code snippet particles
                const group = new THREE.Group();
                const codeSnippets = ['{}', '[]', '=>', 'fn', 'async', 'await', 'class', 'const'];
                
                codeSnippets.forEach((snippet, index) => {
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.width = 128;
                    canvas.height = 64;
                    
                    context.fillStyle = '#3B82F6';
                    context.font = 'bold 32px monospace';
                    context.textAlign = 'center';
                    context.textBaseline = 'middle';
                    context.fillText(snippet, 64, 32);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    const material = new THREE.SpriteMaterial({
                        map: texture,
                        transparent: true,
                        opacity: 0.6
                    });
                    
                    const sprite = new THREE.Sprite(material);
                    sprite.scale.set(4, 2, 1);
                    sprite.position.set(
                        (Math.random() - 0.5) * 30,
                        Math.random() * 10,
                        (Math.random() - 0.5) * 30
                    );
                    
                    group.add(sprite);
                });
                
                return group;
            }
            
            createAPIEndpoints() {
                // Create 3D visualization of API endpoints
                const group = new THREE.Group();
                const endpoints = [
                    { path: '/agent/create', method: 'POST', color: 0x10B981 },
                    { path: '/agent/connect', method: 'GET', color: 0x3B82F6 },
                    { path: '/zkp/generate', method: 'POST', color: 0x8B5CF6 },
                    { path: '/federation/join', method: 'PUT', color: 0xF59E0B }
                ];
                
                endpoints.forEach((endpoint, index) => {
                    const boxGeometry = new THREE.BoxGeometry(8, 1.5, 0.5);
                    const boxMaterial = new THREE.MeshPhysicalMaterial({
                        color: endpoint.color,
                        metalness: 0.5,
                        roughness: 0.2,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const box = new THREE.Mesh(boxGeometry, boxMaterial);
                    box.position.set(15, 5 - index * 2, 0);
                    
                    group.add(box);
                });
                
                return group;
            }
            
            animateCodeTyping() {
                // Simulate typing effect in code editor
                const codeLines = document.querySelectorAll('.code-line');
                codeLines.forEach((line, index) => {
                    line.style.opacity = '0';
                    setTimeout(() => {
                        line.style.opacity = '1';
                        line.style.animation = 'fadeIn 0.3s ease';
                    }, index * 100);
                });
            }
            
            setSceneMood(mood) {
                // Adjust lighting and atmosphere based on section
                switch(mood) {
                    case 'default':
                        this.scene.fog.color.setHex(0x000011);
                        this.keyLight.intensity = 2;
                        break;
                    case 'overview':
                        this.scene.fog.color.setHex(0x001122);
                        this.keyLight.intensity = 2.5;
                        break;
                    case 'technical':
                        this.scene.fog.color.setHex(0x000022);
                        this.keyLight.intensity = 1.8;
                        break;
                    case 'developer':
                        this.scene.fog.color.setHex(0x001100);
                        this.keyLight.intensity = 2.2;
                        break;
                }
            }
            
            navigateToPreviousSection() {
                const sections = ['home', 'overview', 'architecture', 'developers'];
                const currentIndex = sections.indexOf(this.currentSection);
                if (currentIndex > 0) {
                    this.navigateToSection(sections[currentIndex - 1]);
                }
            }
            
            navigateToNextSection() {
                const sections = ['home', 'overview', 'architecture', 'developers'];
                const currentIndex = sections.indexOf(this.currentSection);
                if (currentIndex < sections.length - 1) {
                    this.navigateToSection(sections[currentIndex + 1]);
                }
            }
            
            resetCamera() {
                this.targetCameraAngle = 0;
                this.targetCameraRadius = 40;
                this.targetCameraHeight = 10;
            }
            
            startIntroAnimation() {
                // Spectacular entrance animation
                this.crystals.forEach((crystal, index) => {
                    // Store original scale
                    crystal.originalScale = crystal.mesh.scale.clone();
                    
                    // Start from zero
                    crystal.mesh.scale.set(0, 0, 0);
                    
                    // Animate in with delay
                    setTimeout(() => {
                        const startTime = this.clock.getElapsedTime();
                        const animateIn = () => {
                            const elapsed = this.clock.getElapsedTime() - startTime;
                            const progress = Math.min(elapsed * 2, 1);
                            
                            // Elastic easing
                            const elasticProgress = 1 - Math.pow(2, -10 * progress) * Math.cos(progress * Math.PI * 3);
                            
                            crystal.mesh.scale.copy(crystal.originalScale);
                            crystal.mesh.scale.multiplyScalar(elasticProgress);
                            
                            if (progress < 1) {
                                requestAnimationFrame(animateIn);
                            } else {
                                // Create explosion effect when crystal appears
                                this.createCrystalBurst(crystal.mesh.position);
                            }
                        };
                        animateIn();
                    }, index * 200);
                });
                
                // Animate camera entrance
                const originalCameraRadius = this.cameraRadius;
                this.cameraRadius = 100;
                this.targetCameraRadius = originalCameraRadius;
                
                // Particle system entrance
                if (this.particleSystem) {
                    this.particleSystem.material.opacity = 0;
                    const fadeInParticles = () => {
                        if (this.particleSystem.material.opacity < 0.8) {
                            this.particleSystem.material.opacity += 0.01;
                            requestAnimationFrame(fadeInParticles);
                        }
                    };
                    setTimeout(fadeInParticles, 1500);
                }
            }
            
            createCrystalBurst(position) {
                // Create particle burst effect
                const particleCount = 100;
                const particles = [];
                
                for (let i = 0; i < particleCount; i++) {
                    const particle = new THREE.Mesh(
                        new THREE.SphereGeometry(0.1, 4, 4),
                        new THREE.MeshBasicMaterial({
                            color: new THREE.Color().setHSL(Math.random(), 1, 0.7),
                            transparent: true
                        })
                    );
                    
                    particle.position.copy(position);
                    particle.velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 20,
                        (Math.random() - 0.5) * 20,
                        (Math.random() - 0.5) * 20
                    );
                    
                    this.scene.add(particle);
                    particles.push(particle);
                }
                
                // Animate burst
                const animateBurst = () => {
                    let allDone = true;
                    
                    particles.forEach(particle => {
                        if (particle.material.opacity > 0) {
                            particle.position.add(particle.velocity.clone().multiplyScalar(0.1));
                            particle.velocity.multiplyScalar(0.95);
                            particle.material.opacity -= 0.02;
                            allDone = false;
                        } else {
                            this.scene.remove(particle);
                            particle.geometry.dispose();
                            particle.material.dispose();
                        }
                    });
                    
                    if (!allDone) {
                        requestAnimationFrame(animateBurst);
                    }
                };
                animateBurst();
            }
            
            showHint(text) {
                const hint = document.getElementById('hint');
                hint.textContent = text;
                hint.style.animation = 'none';
                setTimeout(() => {
                    hint.style.animation = 'fadeInOut 5s ease';
                }, 10);
            }
            
            setPerformanceMode(mode) {
                // Update button states
                document.querySelectorAll('.perf-btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById(`perf${mode.charAt(0).toUpperCase() + mode.slice(1)}`).classList.add('active');
                
                switch(mode) {
                    case 'low':
                        // Eco mode - reduce quality for better performance
                        this.renderer.setPixelRatio(1);
                        this.renderer.shadowMap.enabled = false;
                        if (this.particleSystem) {
                            this.particleSystem.visible = false;
                        }
                        this.showParticles = false;
                        document.getElementById('particlesBtn').classList.remove('active');
                        
                        // Reduce particle count
                        if (this.particleSystem && this.particleSystem.geometry.attributes.position.count > 10000) {
                            this.createReducedParticleSystem(10000);
                        }
                        break;
                        
                    case 'medium':
                        // Balanced mode
                        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
                        this.renderer.shadowMap.enabled = true;
                        this.renderer.shadowMap.type = THREE.PCFShadowMap;
                        if (this.particleSystem) {
                            this.particleSystem.visible = this.showParticles;
                        }
                        
                        // Medium particle count
                        if (this.particleSystem && this.particleSystem.geometry.attributes.position.count > 50000) {
                            this.createReducedParticleSystem(25000);
                        }
                        break;
                        
                    case 'high':
                        // Ultra mode - maximum quality
                        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                        this.renderer.shadowMap.enabled = true;
                        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                        if (this.particleSystem) {
                            this.particleSystem.visible = this.showParticles;
                        }
                        
                        // Create extra particles for ultra mode
                        this.createEnhancedParticleSystem();
                        break;
                }
                
                this.showHint(`Performance mode: ${mode.toUpperCase()} - ${mode === 'low' ? 'Better FPS' : mode === 'medium' ? 'Balanced' : 'Maximum Quality'}`);
            }
            
            createReducedParticleSystem(count) {
                // Remove old particle system
                if (this.particleSystem) {
                    this.scene.remove(this.particleSystem);
                    this.particleSystem.geometry.dispose();
                    this.particleSystem.material.dispose();
                }
                
                // Create new one with reduced count
                const positions = new Float32Array(count * 3);
                const colors = new Float32Array(count * 3);
                const sizes = new Float32Array(count);
                
                for (let i = 0; i < count; i++) {
                    const i3 = i * 3;
                    const radius = 30 + Math.random() * 50;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    
                    positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    positions[i3 + 2] = radius * Math.cos(phi);
                    
                    const color = new THREE.Color();
                    color.setHSL(0.6 - (radius / 80) * 0.4, 0.8, 0.5);
                    colors[i3] = color.r;
                    colors[i3 + 1] = color.g;
                    colors[i3 + 2] = color.b;
                    
                    sizes[i] = Math.random() * 2;
                }
                
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                const material = new THREE.PointsMaterial({
                    size: 0.1,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true
                });
                
                this.particleSystem = new THREE.Points(geometry, material);
                this.particleSystem.visible = this.showParticles;
                this.scene.add(this.particleSystem);
            }
            
            createEnhancedParticleSystem() {
                // For ultra mode, add even more particles if not already at max
                if (this.particleSystem && this.particleSystem.geometry.attributes.position.count < 100000) {
                    this.createReducedParticleSystem(100000);
                }
            }

            setupPostProcessing() {
                // Advanced post-processing effects would go here
                // For now, we'll use built-in renderer features
            }

            setupLighting() {
                // Ambient light for base illumination
                const ambientLight = new THREE.AmbientLight(0x0a0a1a, 0.5);
                this.scene.add(ambientLight);

                // Key light - main directional light
                this.keyLight = new THREE.DirectionalLight(0x4080ff, 2);
                this.keyLight.position.set(20, 30, 20);
                this.keyLight.castShadow = true;
                this.keyLight.shadow.camera.near = 0.1;
                this.keyLight.shadow.camera.far = 100;
                this.keyLight.shadow.camera.left = -50;
                this.keyLight.shadow.camera.right = 50;
                this.keyLight.shadow.camera.top = 50;
                this.keyLight.shadow.camera.bottom = -50;
                this.keyLight.shadow.mapSize.width = 4096;
                this.keyLight.shadow.mapSize.height = 4096;
                this.keyLight.shadow.bias = -0.0005;
                this.scene.add(this.keyLight);

                // Rim lights for edge highlighting
                const rimLight1 = new THREE.DirectionalLight(0x8B5CF6, 1.5);
                rimLight1.position.set(-20, 20, -20);
                this.scene.add(rimLight1);

                const rimLight2 = new THREE.DirectionalLight(0x10B981, 1);
                rimLight2.position.set(20, 10, -30);
                this.scene.add(rimLight2);

                // Point lights for localized effects
                this.pointLights = [];
                const colors = [0x3B82F6, 0x8B5CF6, 0x10B981, 0xF59E0B];
                for (let i = 0; i < 4; i++) {
                    const light = new THREE.PointLight(colors[i], 3, 30);
                    const angle = (i / 4) * Math.PI * 2;
                    light.position.set(
                        Math.cos(angle) * 15,
                        5 + Math.random() * 10,
                        Math.sin(angle) * 15
                    );
                    this.scene.add(light);
                    this.pointLights.push(light);
                }
            }

            createQuantumField() {
                // Create the base platform with advanced materials
                const platformGeometry = new THREE.CylinderGeometry(20, 25, 2, 64, 1, false);
                
                // Custom shader material for the platform
                const platformMaterial = new THREE.MeshPhysicalMaterial({
                    color: 0x0a0a1a,
                    metalness: 0.9,
                    roughness: 0.1,
                    clearcoat: 1,
                    clearcoatRoughness: 0,
                    reflectivity: 1,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });

                this.platform = new THREE.Mesh(platformGeometry, platformMaterial);
                this.platform.position.y = -10;
                this.platform.receiveShadow = true;
                this.scene.add(this.platform);

                // Add radial pattern overlay
                const patternGeometry = new THREE.RingGeometry(0.1, 20, 64, 32);
                const patternMaterial = new THREE.MeshBasicMaterial({
                    color: 0x3B82F6,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });

                for (let i = 0; i < 16; i++) {
                    const ring = new THREE.Mesh(patternGeometry, patternMaterial);
                    ring.rotation.x = -Math.PI / 2;
                    ring.position.y = -9 + i * 0.01;
                    ring.scale.setScalar(0.1 + (i / 16) * 0.9);
                    this.platform.add(ring);
                }

                // Energy grid on platform
                const gridHelper = new THREE.GridHelper(40, 40, 0x3B82F6, 0x1a1a2e);
                gridHelper.position.y = -8.9;
                gridHelper.material.opacity = 0.2;
                gridHelper.material.transparent = true;
                this.scene.add(gridHelper);
            }

            createCrystallineStructures() {
                this.crystals = [];
                const crystalGroup = new THREE.Group();

                // Define crystal components
                const components = [
                    { name: 'Identity Core', color: 0x3B82F6, position: new THREE.Vector3(-8, 0, 0), scale: 2 },
                    { name: 'Federation Node', color: 0x8B5CF6, position: new THREE.Vector3(8, 0, 0), scale: 2 },
                    { name: 'ZKP Engine', color: 0x10B981, position: new THREE.Vector3(0, 0, -8), scale: 1.8 },
                    { name: 'TEG Processor', color: 0xEF4444, position: new THREE.Vector3(0, 0, 8), scale: 1.8 },
                    { name: 'Apex Controller', color: 0xF59E0B, position: new THREE.Vector3(0, 8, 0), scale: 2.5 },
                    { name: 'Protocol Core', color: 0x06B6D4, position: new THREE.Vector3(0, -5, 0), scale: 1.5 }
                ];

                components.forEach((comp, index) => {
                    const crystal = this.createAdvancedCrystal(comp);
                    crystal.position.copy(comp.position);
                    crystalGroup.add(crystal);
                    this.crystals.push({
                        mesh: crystal,
                        data: comp,
                        originalPosition: comp.position.clone(),
                        phase: Math.random() * Math.PI * 2
                    });
                });

                this.scene.add(crystalGroup);
                this.crystalGroup = crystalGroup;
            }

            createAdvancedCrystal(data) {
                const group = new THREE.Group();

                // Main crystal geometry with subdivision
                const geometry = new THREE.IcosahedronGeometry(data.scale, 2);
                
                // Advanced crystal material with refraction
                const material = new THREE.MeshPhysicalMaterial({
                    color: data.color,
                    metalness: 0.2,
                    roughness: 0.1,
                    transmission: 0.9,
                    thickness: 1.5,
                    ior: 2.4,
                    clearcoat: 1,
                    clearcoatRoughness: 0,
                    transparent: true,
                    opacity: 0.9,
                    side: THREE.DoubleSide,
                    envMapIntensity: 1
                });

                const crystal = new THREE.Mesh(geometry, material);
                crystal.castShadow = true;
                crystal.receiveShadow = true;
                group.add(crystal);

                // Inner core with emissive material
                const coreGeometry = new THREE.IcosahedronGeometry(data.scale * 0.3, 1);
                const coreMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    emissive: data.color,
                    emissiveIntensity: 2
                });
                const core = new THREE.Mesh(coreGeometry, coreMaterial);
                group.add(core);

                // Outer wireframe shell
                const wireframeGeometry = new THREE.IcosahedronGeometry(data.scale * 1.2, 1);
                const wireframeMaterial = new THREE.MeshBasicMaterial({
                    color: data.color,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.3
                });
                const wireframe = new THREE.Mesh(wireframeGeometry, wireframeMaterial);
                group.add(wireframe);

                // Energy field
                const fieldGeometry = new THREE.SphereGeometry(data.scale * 2, 32, 32);
                const fieldMaterial = new THREE.MeshBasicMaterial({
                    color: data.color,
                    transparent: true,
                    opacity: 0.1,
                    side: THREE.BackSide
                });
                const field = new THREE.Mesh(fieldGeometry, fieldMaterial);
                group.add(field);

                // Store references for animation
                group.userData = {
                    crystal,
                    core,
                    wireframe,
                    field,
                    color: data.color,
                    name: data.name
                };

                return group;
            }

            createEnergyFlows() {
                this.energyFlows = [];
                
                // Create energy connections between crystals
                for (let i = 0; i < this.crystals.length; i++) {
                    for (let j = i + 1; j < this.crystals.length; j++) {
                        const flow = this.createEnergyFlow(
                            this.crystals[i].originalPosition,
                            this.crystals[j].originalPosition
                        );
                        this.scene.add(flow);
                        this.energyFlows.push(flow);
                    }
                }
            }

            createEnergyFlow(start, end) {
                const points = [];
                const segments = 50;
                
                for (let i = 0; i <= segments; i++) {
                    const t = i / segments;
                    const point = new THREE.Vector3().lerpVectors(start, end, t);
                    
                    // Add wave distortion
                    const wave = Math.sin(t * Math.PI) * 2;
                    point.y += wave;
                    
                    points.push(point);
                }

                const curve = new THREE.CatmullRomCurve3(points);
                const tubeGeometry = new THREE.TubeGeometry(curve, 50, 0.1, 8, false);
                
                const tubeMaterial = new THREE.MeshBasicMaterial({
                    color: 0x3B82F6,
                    transparent: true,
                    opacity: 0.4,
                    emissive: 0x3B82F6,
                    emissiveIntensity: 1
                });

                const flow = new THREE.Mesh(tubeGeometry, tubeMaterial);
                flow.userData = { curve, progress: 0 };
                
                return flow;
            }

            createHolographicInterface() {
                // Create floating holographic UI elements
                this.holoElements = [];
                
                const uiRadius = 25;
                const uiCount = 8;
                
                for (let i = 0; i < uiCount; i++) {
                    const angle = (i / uiCount) * Math.PI * 2;
                    const x = Math.cos(angle) * uiRadius;
                    const z = Math.sin(angle) * uiRadius;
                    
                    const element = this.createHoloPanel();
                    element.position.set(x, 5, z);
                    element.lookAt(0, 5, 0);
                    this.scene.add(element);
                    this.holoElements.push(element);
                }
            }

            createHoloPanel() {
                const group = new THREE.Group();
                
                // Panel geometry
                const geometry = new THREE.PlaneGeometry(4, 6, 32, 32);
                
                // Holographic material
                const material = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.2,
                    side: THREE.DoubleSide,
                    wireframe: true
                });
                
                const panel = new THREE.Mesh(geometry, material);
                group.add(panel);
                
                // Add data visualization elements
                const dataGeometry = new THREE.BoxGeometry(0.1, 3, 0.1);
                const dataMaterial = new THREE.MeshBasicMaterial({
                    color: 0x3B82F6,
                    emissive: 0x3B82F6,
                    emissiveIntensity: 1
                });
                
                for (let i = 0; i < 5; i++) {
                    const bar = new THREE.Mesh(dataGeometry, dataMaterial);
                    bar.position.x = (i - 2) * 0.6;
                    bar.position.y = -1;
                    bar.scale.y = 0.3 + Math.random() * 0.7;
                    group.add(bar);
                }
                
                return group;
            }

            createParticleUniverse() {
                // Create massive particle system
                const particleCount = 50000;
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                const sizes = new Float32Array(particleCount);
                
                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;
                    
                    // Spherical distribution
                    const radius = 30 + Math.random() * 50;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    
                    positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    positions[i3 + 2] = radius * Math.cos(phi);
                    
                    // Color based on distance
                    const color = new THREE.Color();
                    color.setHSL(0.6 - (radius / 80) * 0.4, 0.8, 0.5);
                    colors[i3] = color.r;
                    colors[i3 + 1] = color.g;
                    colors[i3 + 2] = color.b;
                    
                    sizes[i] = Math.random() * 2;
                }
                
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                const material = new THREE.PointsMaterial({
                    size: 0.1,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true
                });
                
                this.particleSystem = new THREE.Points(geometry, material);
                this.scene.add(this.particleSystem);
            }

            setupControls() {
                // Custom orbital controls
                this.cameraAngle = 0;
                this.cameraRadius = 40;
                this.cameraHeight = 10;
                this.targetCameraAngle = 0;
                this.targetCameraRadius = 40;
                this.targetCameraHeight = 10;
                
                this.isDragging = false;
                this.previousMouseX = 0;
                this.previousMouseY = 0;
            }

            setupEventListeners() {
                // Mouse events
                window.addEventListener('mousemove', (e) => this.onMouseMove(e));
                window.addEventListener('mousedown', (e) => this.onMouseDown(e));
                window.addEventListener('mouseup', () => this.onMouseUp());
                window.addEventListener('wheel', (e) => this.onWheel(e));
                window.addEventListener('dblclick', (e) => this.onDoubleClick(e));
                
                // Window resize
                window.addEventListener('resize', () => this.onResize());
                
                // Control buttons
                document.getElementById('autoRotate').addEventListener('click', () => {
                    this.autoRotate = !this.autoRotate;
                    document.getElementById('autoRotate').classList.toggle('active');
                });
                
                document.getElementById('particlesBtn').addEventListener('click', () => {
                    this.showParticles = !this.showParticles;
                    if (this.particleSystem) {
                        this.particleSystem.visible = this.showParticles;
                    }
                    document.getElementById('particlesBtn').classList.toggle('active');
                });
                
                document.getElementById('sound').addEventListener('click', () => {
                    this.soundEnabled = !this.soundEnabled;
                    document.getElementById('sound').classList.toggle('active');
                    this.toggleSound();
                    
                    // Visual feedback
                    if (this.soundEnabled && this.audioInitialized) {
                        this.createSoundWave();
                    }
                });
                
                // Performance mode toggles
                document.getElementById('perfLow').addEventListener('click', () => this.setPerformanceMode('low'));
                document.getElementById('perfMed').addEventListener('click', () => this.setPerformanceMode('medium'));
                document.getElementById('perfHigh').addEventListener('click', () => this.setPerformanceMode('high'));
            }

            onMouseMove(event) {
                // Update mouse position
                this.mouse.x = (event.clientX / this.width) * 2 - 1;
                this.mouse.y = -(event.clientY / this.height) * 2 + 1;
                
                // Update custom cursor
                const cursor = document.querySelector('.cursor');
                const cursorDot = document.querySelector('.cursor-dot');
                cursor.style.left = event.clientX - 10 + 'px';
                cursor.style.top = event.clientY - 10 + 'px';
                cursorDot.style.left = event.clientX - 2 + 'px';
                cursorDot.style.top = event.clientY - 2 + 'px';
                
                // Camera rotation when dragging
                if (this.isDragging) {
                    const deltaX = event.clientX - this.previousMouseX;
                    const deltaY = event.clientY - this.previousMouseY;
                    
                    this.targetCameraAngle += deltaX * 0.01;
                    this.targetCameraHeight = Math.max(-20, Math.min(30, this.targetCameraHeight - deltaY * 0.1));
                    
                    this.previousMouseX = event.clientX;
                    this.previousMouseY = event.clientY;
                }
            }

            onMouseDown(event) {
                this.isDragging = true;
                this.previousMouseX = event.clientX;
                this.previousMouseY = event.clientY;
                document.querySelector('.cursor').style.transform = 'scale(0.8)';
            }

            onMouseUp() {
                this.isDragging = false;
                document.querySelector('.cursor').style.transform = 'scale(1)';
            }

            onWheel(event) {
                this.targetCameraRadius = Math.max(20, Math.min(80, this.targetCameraRadius + event.deltaY * 0.05));
            }

            onDoubleClick(event) {
                // Raycast to find clicked object
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.crystalGroup.children, true);
                
                if (intersects.length > 0) {
                    const target = intersects[0].object.parent;
                    this.focusOnCrystal(target);
                    
                    // Play click sound
                    if (this.soundEnabled && this.interactionSounds) {
                        this.interactionSounds.click();
                    }
                    
                    // Create ripple effect
                    this.createRippleEffect(intersects[0].point);
                }
            }
            
            createRippleEffect(position) {
                const rippleGeometry = new THREE.RingGeometry(0.1, 0.5, 32);
                const rippleMaterial = new THREE.MeshBasicMaterial({
                    color: 0x3B82F6,
                    transparent: true,
                    opacity: 1,
                    side: THREE.DoubleSide
                });
                
                const ripple = new THREE.Mesh(rippleGeometry, rippleMaterial);
                ripple.position.copy(position);
                ripple.lookAt(this.camera.position);
                this.scene.add(ripple);
                
                // Animate ripple
                const startTime = this.clock.getElapsedTime();
                const animateRipple = () => {
                    const elapsed = this.clock.getElapsedTime() - startTime;
                    if (elapsed < 1) {
                        ripple.scale.setScalar(1 + elapsed * 10);
                        ripple.material.opacity = 1 - elapsed;
                        requestAnimationFrame(animateRipple);
                    } else {
                        this.scene.remove(ripple);
                        ripple.geometry.dispose();
                        ripple.material.dispose();
                    }
                };
                animateRipple();
            }
            
            createSoundWave() {
                // Visual representation of sound activation
                const waveGeometry = new THREE.SphereGeometry(1, 32, 32);
                const waveMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.5,
                    wireframe: true
                });
                
                const wave = new THREE.Mesh(waveGeometry, waveMaterial);
                wave.position.set(0, 0, 0);
                this.scene.add(wave);
                
                // Animate sound wave
                const startTime = this.clock.getElapsedTime();
                const animateWave = () => {
                    const elapsed = this.clock.getElapsedTime() - startTime;
                    if (elapsed < 2) {
                        wave.scale.setScalar(1 + elapsed * 20);
                        wave.material.opacity = 0.5 - elapsed * 0.25;
                        requestAnimationFrame(animateWave);
                    } else {
                        this.scene.remove(wave);
                        wave.geometry.dispose();
                        wave.material.dispose();
                    }
                };
                animateWave();
            }

            focusOnCrystal(crystal) {
                // Animate camera to focus on crystal
                const targetPosition = crystal.position.clone();
                targetPosition.y += 5;
                
                // Calculate angle to crystal
                const angle = Math.atan2(targetPosition.z, targetPosition.x);
                this.targetCameraAngle = angle;
                this.targetCameraRadius = 15;
                this.targetCameraHeight = targetPosition.y;
                
                // Show crystal details if in architecture mode
                if (this.currentSection === 'architecture') {
                    this.showCrystalDetails(crystal.userData.name);
                }
            }
            
            showCrystalDetails(name) {
                // Enhanced crystal info display for architecture section
                const panel = document.getElementById('architecturePanel');
                const details = {
                    'Identity Core': {
                        title: 'Identity Core - SPIFFE/SPIRE',
                        specs: [
                            'X.509 SVIDs for cryptographic identity',
                            'Zero-trust architecture foundation',
                            'Automatic certificate rotation',
                            'Hardware security module support'
                        ]
                    },
                    'Federation Node': {
                        title: 'Federation Network - P2P Mesh',
                        specs: [
                            'Kademlia DHT for peer discovery',
                            'WebRTC data channels',
                            'NAT traversal with STUN/TURN',
                            'Byzantine fault tolerance'
                        ]
                    },
                    'ZKP Engine': {
                        title: 'ZKP Engine - Groth16',
                        specs: [
                            'Groth16 proof system',
                            'Custom circuit compiler',
                            'GPU acceleration support',
                            'Batch verification optimization'
                        ]
                    }
                };
                
                if (details[name]) {
                    const detail = details[name];
                    // Update panel content with specific component details
                    // This would be enhanced with more detailed information
                }
            }

            onResize() {
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                
                this.camera.aspect = this.width / this.height;
                this.camera.updateProjectionMatrix();
                
                this.renderer.setSize(this.width, this.height);
            }

            setupAudio() {
                // Audio context for sound-reactive features
                this.audioContext = null;
                this.analyser = null;
                this.dataArray = null;
                this.audioInitialized = false;
                this.frequencies = [];
                
                // Create ambient soundscape
                this.createAmbientSound();
            }
            
            createAmbientSound() {
                // Initialize Web Audio API on first user interaction
                const initAudio = () => {
                    if (this.audioInitialized) return;
                    
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.audioInitialized = true;
                    
                    // Create master gain
                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.gain.value = 0;
                    this.masterGain.connect(this.audioContext.destination);
                    
                    // Create ambient drone sounds
                    this.oscillators = [];
                    const baseFrequencies = [55, 110, 165, 220, 330]; // A harmonic series
                    
                    baseFrequencies.forEach((freq, index) => {
                        // Main oscillator
                        const osc = this.audioContext.createOscillator();
                        osc.type = 'sine';
                        osc.frequency.value = freq;
                        
                        // Create subtle vibrato
                        const vibrato = this.audioContext.createOscillator();
                        vibrato.frequency.value = 0.5 + index * 0.1;
                        const vibratoGain = this.audioContext.createGain();
                        vibratoGain.gain.value = 0.5;
                        vibrato.connect(vibratoGain);
                        vibratoGain.connect(osc.frequency);
                        vibrato.start();
                        
                        // Individual gain for each oscillator
                        const gain = this.audioContext.createGain();
                        gain.gain.value = 0.1 / (index + 1);
                        
                        // Add filter for warmth
                        const filter = this.audioContext.createBiquadFilter();
                        filter.type = 'lowpass';
                        filter.frequency.value = 800 - index * 100;
                        filter.Q.value = 1;
                        
                        // Connect chain
                        osc.connect(filter);
                        filter.connect(gain);
                        gain.connect(this.masterGain);
                        
                        osc.start();
                        
                        this.oscillators.push({
                            oscillator: osc,
                            gain: gain,
                            filter: filter,
                            vibrato: vibrato,
                            baseFreq: freq
                        });
                    });
                    
                    // Create interaction sounds
                    this.createInteractionSounds();
                };
                
                // Initialize on first interaction
                document.addEventListener('click', initAudio, { once: true });
                document.addEventListener('keydown', initAudio, { once: true });
            }
            
            createInteractionSounds() {
                // Prepare sound effects for interactions
                this.interactionSounds = {
                    hover: () => {
                        const osc = this.audioContext.createOscillator();
                        const gain = this.audioContext.createGain();
                        
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(800, this.audioContext.currentTime);
                        osc.frequency.exponentialRampToValueAtTime(1600, this.audioContext.currentTime + 0.1);
                        
                        gain.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                        
                        osc.connect(gain);
                        gain.connect(this.masterGain);
                        
                        osc.start();
                        osc.stop(this.audioContext.currentTime + 0.1);
                    },
                    click: () => {
                        const osc = this.audioContext.createOscillator();
                        const gain = this.audioContext.createGain();
                        
                        osc.type = 'triangle';
                        osc.frequency.value = 440;
                        
                        gain.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                        
                        osc.connect(gain);
                        gain.connect(this.masterGain);
                        
                        osc.start();
                        osc.stop(this.audioContext.currentTime + 0.2);
                    }
                };
                
                // Create transition sound function
                this.transitionSound = () => {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    const filter = this.audioContext.createBiquadFilter();
                    
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(110, this.audioContext.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(880, this.audioContext.currentTime + 0.5);
                    
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(220, this.audioContext.currentTime);
                    filter.frequency.exponentialRampToValueAtTime(4400, this.audioContext.currentTime + 0.5);
                    filter.Q.value = 5;
                    
                    gain.gain.setValueAtTime(0.15, this.audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
                    
                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.masterGain);
                    
                    osc.start();
                    osc.stop(this.audioContext.currentTime + 0.5);
                };
            }
            
            toggleSound() {
                if (this.soundEnabled && this.audioInitialized) {
                    // Fade in
                    this.masterGain.gain.cancelScheduledValues(this.audioContext.currentTime);
                    this.masterGain.gain.setValueAtTime(this.masterGain.gain.value, this.audioContext.currentTime);
                    this.masterGain.gain.linearRampToValueAtTime(0.3, this.audioContext.currentTime + 1);
                } else if (this.audioInitialized) {
                    // Fade out
                    this.masterGain.gain.cancelScheduledValues(this.audioContext.currentTime);
                    this.masterGain.gain.setValueAtTime(this.masterGain.gain.value, this.audioContext.currentTime);
                    this.masterGain.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + 1);
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                const deltaTime = this.clock.getDelta();
                const elapsedTime = this.clock.getElapsedTime();
                
                // Update camera
                this.updateCamera();
                
                // Update crystals
                this.updateCrystals(elapsedTime);
                
                // Update particle system
                if (this.particleSystem) {
                    this.particleSystem.rotation.y += 0.0001;
                }
                
                // Update holographic elements
                this.updateHolographicElements(elapsedTime);
                
                // Update energy flows
                this.updateEnergyFlows(elapsedTime);
                
                // Update performance stats
                this.updateStats();
                
                // Render
                this.renderer.render(this.scene, this.camera);
            }

            updateCamera() {
                // Smooth camera movement
                this.cameraAngle += (this.targetCameraAngle - this.cameraAngle) * 0.05;
                this.cameraRadius += (this.targetCameraRadius - this.cameraRadius) * 0.05;
                this.cameraHeight += (this.targetCameraHeight - this.cameraHeight) * 0.05;
                
                // Auto-rotate
                if (this.autoRotate && !this.isDragging) {
                    this.targetCameraAngle += 0.002;
                }
                
                // Update camera position
                this.camera.position.x = Math.cos(this.cameraAngle) * this.cameraRadius;
                this.camera.position.y = this.cameraHeight;
                this.camera.position.z = Math.sin(this.cameraAngle) * this.cameraRadius;
                this.camera.lookAt(0, 0, 0);
            }

            updateCrystals(time) {
                this.crystals.forEach((crystal, index) => {
                    // Floating animation
                    crystal.mesh.position.y = crystal.originalPosition.y + Math.sin(time * 0.001 + crystal.phase) * 0.5;
                    
                    // Rotation
                    crystal.mesh.rotation.y += 0.005;
                    crystal.mesh.rotation.x = Math.sin(time * 0.0005 + index) * 0.1;
                    
                    // Pulsing wireframe
                    if (crystal.mesh.userData.wireframe) {
                        crystal.mesh.userData.wireframe.material.opacity = 0.3 + Math.sin(time * 0.002 + index) * 0.2;
                    }
                    
                    // Energy field pulsing
                    if (crystal.mesh.userData.field) {
                        const scale = 1 + Math.sin(time * 0.001 + crystal.phase) * 0.1;
                        crystal.mesh.userData.field.scale.setScalar(scale);
                    }
                });
            }

            updateHolographicElements(time) {
                this.holoElements.forEach((element, index) => {
                    // Gentle floating
                    element.position.y = 5 + Math.sin(time * 0.0005 + index * 0.5) * 0.5;
                    
                    // Look at camera for billboard effect
                    element.lookAt(this.camera.position);
                    
                    // Update data bars
                    element.children.forEach((child, i) => {
                        if (child.geometry.type === 'BoxGeometry' && i > 0) {
                            const targetScale = 0.3 + Math.random() * 0.7;
                            child.scale.y += (targetScale - child.scale.y) * 0.05;
                        }
                    });
                });
            }

            updateEnergyFlows(time) {
                this.energyFlows.forEach((flow, index) => {
                    // Animate flow progress
                    flow.userData.progress += 0.01;
                    if (flow.userData.progress > 1) flow.userData.progress = 0;
                    
                    // Update material opacity for pulse effect
                    flow.material.opacity = 0.2 + Math.sin(time * 0.002 + index) * 0.2;
                });
            }

            updateStats() {
                // Update FPS
                const fps = Math.round(1 / this.clock.getDelta());
                document.getElementById('fps').textContent = fps;
                
                // Update other stats periodically
                if (Math.random() > 0.95) {
                    document.getElementById('particles').textContent = 
                        this.particleSystem ? `${(this.particleSystem.geometry.attributes.position.count / 1000).toFixed(0)}K` : '0';
                    
                    document.getElementById('vertices').textContent = 
                        `${(this.renderer.info.render.triangles / 1000000).toFixed(1)}M`;
                    
                    document.getElementById('drawCalls').textContent = 
                        this.renderer.info.render.calls;
                }
            }
        }

        // Initialize visualization
        new QuantumVisualization();
    </script>
</body>
</html>