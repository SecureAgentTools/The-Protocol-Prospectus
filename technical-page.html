<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Technical Architecture - The Protocol</title>
    
    <!-- SEO & Open Graph -->
    <meta name="description" content="Discover the revolutionary technical architecture behind The Protocol: Federation Protocol, Zero-Knowledge Proofs, and the Token Economic Graph powering the autonomous agent economy.">
    <meta property="og:title" content="The Protocol Technical Architecture - 1000x Faster Than Blockchain">
    <meta property="og:description" content="No blockchain. No gas fees. Just pure distributed systems engineering. See how we built the TCP/IP of autonomous agents.">
    <meta property="og:image" content="https://www.theprotocol.cloud/tech-preview.png">
    <meta property="og:url" content="https://www.theprotocol.cloud/technical.html">
    
    <!-- Structured Data for SEO -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "TechArticle",
      "headline": "The Protocol Technical Architecture",
      "description": "Complete technical documentation for The Protocol sovereign agent protocol",
      "author": {
        "@type": "Organization",
        "name": "The Protocol"
      },
      "datePublished": "2025-01-27",
      "keywords": "autonomous agents, distributed systems, zero-knowledge proofs, federation protocol"
    }
    </script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-glow: #3B82F6;
            --secondary-glow: #8B5CF6;
            --accent-glow: #10B981;
            --danger-glow: #EF4444;
            --bg-void: #000000;
            --bg-deep: #0a0a0a;
            --bg-dark: #0F172A;
            --bg-card: rgba(15, 23, 42, 0.6);
            --text-bright: #FFFFFF;
            --text-primary: #F8FAFC;
            --text-secondary: #94A3B8;
            --text-muted: #475569;
            --gradient-primary: linear-gradient(135deg, #3B82F6 0%, #8B5CF6 100%);
            --gradient-accent: linear-gradient(135deg, #10B981 0%, #3B82F6 100%);
            --gradient-danger: linear-gradient(135deg, #EF4444 0%, #8B5CF6 100%);
            --gradient-holographic: linear-gradient(45deg, #3B82F6, #8B5CF6, #10B981, #3B82F6);
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg-void);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
        }

        /* Navigation Header */
        .nav-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(10, 10, 10, 0.95);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(59, 130, 246, 0.2);
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .nav-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            height: 80px;
        }

        .nav-logo {
            font-size: 1.5rem;
            font-weight: 900;
            background: linear-gradient(135deg, #3B82F6 0%, #8B5CF6 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-decoration: none;
            letter-spacing: -0.02em;
        }

        .nav-menu {
            display: flex;
            align-items: center;
            gap: 2.5rem;
            list-style: none;
        }

        .nav-link {
            color: var(--text-secondary);
            text-decoration: none;
            font-weight: 500;
            font-size: 0.95rem;
            letter-spacing: 0.01em;
            transition: all 0.3s ease;
            position: relative;
        }

        .nav-link::after {
            content: '';
            position: absolute;
            bottom: -5px;
            left: 0;
            width: 0;
            height: 2px;
            background: var(--gradient-primary);
            transition: width 0.3s ease;
        }

        .nav-link:hover {
            color: var(--text-bright);
        }

        .nav-link:hover::after {
            width: 100%;
        }
        
        .nav-link.active {
            color: var(--primary-glow);
        }
        
        .nav-link.active::after {
            width: 100%;
        }

        .nav-link.nav-cta {
            background: var(--gradient-primary);
            color: var(--text-bright);
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            transition: all 0.3s ease;
        }

        .nav-link.nav-cta:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(59, 130, 246, 0.3);
        }

        .nav-link.nav-cta::after {
            display: none;
        }

        .nav-link.nav-dev-portal {
            background: linear-gradient(135deg, #10B981 0%, #3B82F6 100%);
            color: var(--text-bright);
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        .nav-link.nav-dev-portal:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(16, 185, 129, 0.3);
        }

        .nav-link.nav-dev-portal::after {
            display: none;
        }

        /* Mobile Navigation */
        .nav-toggle {
            display: none;
            flex-direction: column;
            gap: 4px;
            cursor: pointer;
            padding: 0.5rem;
        }

        .nav-toggle span {
            width: 25px;
            height: 2px;
            background: var(--text-bright);
            transition: all 0.3s ease;
        }

        @media (max-width: 968px) {
            .nav-menu {
                position: fixed;
                top: 80px;
                left: 0;
                right: 0;
                background: rgba(10, 10, 10, 0.98);
                flex-direction: column;
                padding: 2rem;
                gap: 1.5rem;
                transform: translateX(-100%);
                transition: transform 0.3s ease;
                border-bottom: 1px solid rgba(59, 130, 246, 0.2);
            }

            .nav-menu.active {
                transform: translateX(0);
            }

            .nav-toggle {
                display: flex;
            }

            .nav-toggle.active span:nth-child(1) {
                transform: rotate(45deg) translate(5px, 5px);
            }

            .nav-toggle.active span:nth-child(2) {
                opacity: 0;
            }

            .nav-toggle.active span:nth-child(3) {
                transform: rotate(-45deg) translate(5px, -5px);
            }
        }

        /* Enhanced Hero with Circuit Board Pattern */
        .hero {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            background: 
                radial-gradient(ellipse at center, rgba(59, 130, 246, 0.15) 0%, transparent 70%),
                url('data:image/svg+xml,<svg width="100" height="100" xmlns="http://www.w3.org/2000/svg"><path d="M10 10h10v10h-10zM80 10h10v10h-10zM10 80h10v10h-10zM80 80h10v10h-10z" fill="rgba(59,130,246,0.05)"/><path d="M15 15h70M15 85h70M15 15v70M85 15v70" stroke="rgba(59,130,246,0.03)" stroke-width="1"/></svg>') repeat;
            overflow: hidden;
            padding: 8rem 2rem 4rem;
        }

        .hero-content {
            text-align: center;
            z-index: 10;
            max-width: 1200px;
            width: 100%;
        }

        .hero h1 {
            font-size: clamp(3rem, 8vw, 6rem);
            font-weight: 900;
            margin-bottom: 1.5rem;
            letter-spacing: -0.02em;
            line-height: 1.1;
        }

        .hero h1 .gradient-text {
            background: linear-gradient(to right, #FFFFFF 0%, #3B82F6 50%, #8B5CF6 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            background-size: 200% auto;
            animation: shine 3s linear infinite;
        }

        @keyframes shine {
            to { background-position: 200% center; }
        }

        .hero .subtitle {
            font-size: clamp(1.5rem, 3vw, 2rem);
            color: var(--text-secondary);
            margin-bottom: 3rem;
            font-weight: 300;
            max-width: 900px;
            margin-left: auto;
            margin-right: auto;
        }

        /* Live Network Visualization */
        #network-viz {
            width: 100%;
            height: 600px;
            margin: 4rem 0;
            background: rgba(15, 23, 42, 0.4);
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 1rem;
            position: relative;
            overflow: hidden;
        }

        /* Performance Metrics Dashboard */
        .metrics-dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 2rem;
            margin: 4rem 0;
        }

        .metric-card {
            background: var(--bg-card);
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 1rem;
            padding: 2rem;
            position: relative;
            overflow: hidden;
        }

        .metric-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--gradient-primary);
        }

        .metric-value {
            font-size: 3rem;
            font-weight: 800;
            background: var(--gradient-primary);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 0.5rem;
        }

        .metric-label {
            font-size: 1rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .metric-change {
            font-size: 0.875rem;
            color: var(--accent-glow);
            margin-top: 0.5rem;
        }

        /* Architecture Comparison */
        .comparison-section {
            padding: 6rem 0;
            background: var(--bg-deep);
        }

        .comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4rem;
            margin-top: 4rem;
        }

        .comparison-card {
            background: rgba(15, 23, 42, 0.6);
            border-radius: 1.5rem;
            padding: 3rem;
            position: relative;
            transition: transform 0.3s ease;
        }

        .comparison-card.agentvault {
            border: 2px solid var(--primary-glow);
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.05) 0%, rgba(139, 92, 246, 0.05) 100%);
        }

        .comparison-card.blockchain {
            border: 1px solid rgba(239, 68, 68, 0.3);
            opacity: 0.8;
        }

        .comparison-title {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 2rem;
        }

        .comparison-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .comparison-metric {
            color: var(--text-secondary);
        }

        .comparison-value {
            font-weight: 600;
            font-size: 1.125rem;
        }

        .agentvault .comparison-value {
            color: var(--accent-glow);
        }

        .blockchain .comparison-value {
            color: var(--danger-glow);
        }

        /* Interactive Architecture Diagram */
        .architecture-visual {
            margin: 4rem 0;
            padding: 3rem;
            background: rgba(15, 23, 42, 0.4);
            border-radius: 1.5rem;
            border: 1px solid rgba(59, 130, 246, 0.2);
        }

        #architecture-canvas {
            width: 100%;
            height: 700px;
        }

        /* Tech Stack Pills */
        .tech-stack {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin: 2rem 0;
        }

        .tech-pill {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 2rem;
            padding: 0.5rem 1.5rem;
            font-size: 0.875rem;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .tech-pill:hover {
            background: rgba(59, 130, 246, 0.2);
            transform: translateY(-2px);
        }

        /* Code Examples */
        .code-example {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 0.75rem;
            padding: 2rem;
            margin: 2rem 0;
            overflow-x: auto;
        }

        .code-example pre {
            font-family: 'JetBrains Mono', 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
            color: var(--accent-glow);
        }

        .code-example .comment {
            color: var(--text-muted);
        }

        .code-example .keyword {
            color: var(--primary-glow);
        }

        .code-example .string {
            color: var(--secondary-glow);
        }

        /* Feature Cards */
        .features-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 2rem;
            margin: 4rem 0;
        }

        .feature-card {
            background: var(--bg-card);
            border: 1px solid transparent;
            border-radius: 1.5rem;
            padding: 2.5rem;
            position: relative;
            overflow: hidden;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
        }

        .feature-card::before {
            content: '';
            position: absolute;
            inset: -2px;
            background: var(--gradient-holographic);
            border-radius: 1.5rem;
            opacity: 0;
            z-index: -1;
            transition: opacity 0.5s ease;
            background-size: 400% 400%;
            animation: holographic 15s ease infinite;
        }

        @keyframes holographic {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .feature-card:hover::before {
            opacity: 1;
        }

        .feature-card:hover {
            transform: translateY(-10px) scale(1.02);
            background: rgba(15, 23, 42, 0.9);
        }

        .feature-icon {
            font-size: 3rem;
            margin-bottom: 1.5rem;
        }

        .feature-title {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 1rem;
            color: var(--text-bright);
        }

        .feature-description {
            color: var(--text-secondary);
            line-height: 1.8;
        }

        /* CTA Section */
        .cta-section {
            padding: 8rem 0;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%);
            text-align: center;
        }

        .cta-buttons {
            display: flex;
            gap: 2rem;
            justify-content: center;
            margin-top: 3rem;
            flex-wrap: wrap;
        }

        .btn-primary, .btn-secondary {
            padding: 1rem 2.5rem;
            font-size: 1.125rem;
            font-weight: 600;
            border-radius: 0.5rem;
            text-decoration: none;
            display: inline-block;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: var(--gradient-primary);
            color: var(--text-bright);
            border: none;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(59, 130, 246, 0.5);
        }

        .btn-secondary {
            background: transparent;
            color: var(--primary-glow);
            border: 2px solid var(--primary-glow);
        }

        .btn-secondary:hover {
            background: rgba(59, 130, 246, 0.1);
        }

        /* Sections */
        section {
            padding: 6rem 0;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 2rem;
        }

        .section-header {
            text-align: center;
            margin-bottom: 4rem;
        }

        .section-title {
            font-size: clamp(2.5rem, 5vw, 4rem);
            font-weight: 800;
            margin-bottom: 1rem;
            background: var(--gradient-primary);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .section-subtitle {
            font-size: 1.5rem;
            color: var(--text-secondary);
            max-width: 800px;
            margin: 0 auto;
        }

        /* Footer */
        footer {
            background: var(--bg-void);
            padding: 4rem 0;
            border-top: 1px solid rgba(59, 130, 246, 0.1);
        }

        .footer-content {
            text-align: center;
            color: var(--text-muted);
        }

        .footer-content a {
            color: var(--primary-glow);
            text-decoration: none;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .comparison-grid {
                grid-template-columns: 1fr;
            }
            
            #network-viz {
                height: 400px;
            }
            
            .hero h1 {
                font-size: clamp(2.5rem, 7vw, 5rem);
            }
            
            .metrics-dashboard {
                grid-template-columns: 1fr;
            }
            
            .features-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <!-- Navigation Header -->
    <header class="nav-header">
        <div class="nav-container">
            <a href="/" class="nav-logo">The Protocol</a>
            <nav>
                <ul class="nav-menu" id="navMenu">
                    <li><a href="/technical-page.html" class="nav-link active">Technical Architecture</a></li>
                    <li><a href="/zkp-page.html" class="nav-link">Zero-Knowledge Proofs</a></li>
                    <li><a href="/attestation.html" class="nav-link">Attestation Network</a></li>
                    <li><a href="/federation.html" class="nav-link">Federation Model</a></li>
                    <li><a href="/governance.html" class="nav-link">Governance</a></li>
                    <li><a href="/developers-page.html" class="nav-link">For Developers</a></li>
                    <li><a href="#" class="nav-link nav-dev-portal">Developer Portal →</a></li>
                    <li><a href="/#application" class="nav-link nav-cta">Join Beta</a></li>
                </ul>
                <div class="nav-toggle" id="navToggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </nav>
        </div>
    </header>

    <!-- Hero Section -->
    <section class="hero">
        <div class="hero-content">
            <h1>
                <span class="gradient-text">The Sovereign Stack</span><br>
                for the Agentic Age
            </h1>
            <p class="subtitle">
                No blockchain. No gas fees. No compromise.<br>
                Just pure distributed systems engineering at its finest.
            </p>
            
            <!-- Live Network Visualization -->
            <div id="network-viz">
                <canvas id="federation-network"></canvas>
            </div>
            
            <!-- Performance Metrics Dashboard -->
            <div class="metrics-dashboard">
                <div class="metric-card">
                    <div class="metric-value">1000x</div>
                    <div class="metric-label">Faster than Blockchain</div>
                    <div class="metric-change">↑ No block confirmations needed</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value"><200ms</div>
                    <div class="metric-label">Agent Creation Time</div>
                    <div class="metric-change">↑ Instant deployment</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">10,000</div>
                    <div class="metric-label">Transactions Per Second</div>
                    <div class="metric-change">↑ Linear scalability</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">$0</div>
                    <div class="metric-label">Gas Fees</div>
                    <div class="metric-change">✓ Reputation-based costs only</div>
                </div>
            </div>
        </div>
    </section>

    <!-- Architecture Comparison -->
    <section class="comparison-section">
        <div class="container">
            <div class="section-header">
                <h2 class="section-title">Why We Abandoned Blockchain</h2>
                <p class="section-subtitle">
                    Side-by-side comparison with blockchain-based agent systems
                </p>
            </div>
            
            <div class="comparison-grid">
                <div class="comparison-card agentvault">
                    <h3 class="comparison-title">The Protocol</h3>
                    <div class="comparison-item">
                        <span class="comparison-metric">Transaction Finality</span>
                        <span class="comparison-value">< 500ms</span>
                    </div>
                    <div class="comparison-item">
                        <span class="comparison-metric">Network Fees</span>
                        <span class="comparison-value">$0 (Reputation-based)</span>
                    </div>
                    <div class="comparison-item">
                        <span class="comparison-metric">Throughput</span>
                        <span class="comparison-value">10,000+ TPS</span>
                    </div>
                    <div class="comparison-item">
                        <span class="comparison-metric">Smart Contracts</span>
                        <span class="comparison-value">Not needed</span>
                    </div>
                    <div class="comparison-item">
                        <span class="comparison-metric">Developer Experience</span>
                        <span class="comparison-value">REST APIs</span>
                    </div>
                    <div class="comparison-item">
                        <span class="comparison-metric">Privacy</span>
                        <span class="comparison-value">ZKP Native</span>
                    </div>
                </div>
                
                <div class="comparison-card blockchain">
                    <h3 class="comparison-title">Blockchain Solutions</h3>
                    <div class="comparison-item">
                        <span class="comparison-metric">Transaction Finality</span>
                        <span class="comparison-value">12-600 seconds</span>
                    </div>
                    <div class="comparison-item">
                        <span class="comparison-metric">Network Fees</span>
                        <span class="comparison-value">$0.50 - $50+</span>
                    </div>
                    <div class="comparison-item">
                        <span class="comparison-metric">Throughput</span>
                        <span class="comparison-value">15-100 TPS</span>
                    </div>
                    <div class="comparison-item">
                        <span class="comparison-metric">Smart Contracts</span>
                        <span class="comparison-value">Required</span>
                    </div>
                    <div class="comparison-item">
                        <span class="comparison-metric">Developer Experience</span>
                        <span class="comparison-value">Solidity/Web3</span>
                    </div>
                    <div class="comparison-item">
                        <span class="comparison-metric">Privacy</span>
                        <span class="comparison-value">Public ledger</span>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Core Architecture -->
    <section style="background: var(--bg-deep);">
        <div class="container">
            <div class="section-header">
                <h2 class="section-title">Revolutionary Architecture</h2>
                <p class="section-subtitle">
                    Four pillars working in perfect harmony to create the future of autonomous systems
                </p>
            </div>
            
            <div class="architecture-visual">
                <div id="architecture-canvas"></div>
            </div>
            
            <div class="features-grid">
                <div class="feature-card">
                    <div class="feature-icon">🔐</div>
                    <h3 class="feature-title">Identity Fabric</h3>
                    <p class="feature-description">
                        SPIFFE/SPIRE provides cryptographically verifiable identities for every agent and service. 
                        Short-lived certificates ensure zero-trust security without the overhead of blockchain wallets.
                    </p>
                    <div class="tech-stack">
                        <span class="tech-pill">SPIFFE</span>
                        <span class="tech-pill">mTLS</span>
                        <span class="tech-pill">X.509 SVIDs</span>
                    </div>
                </div>
                
                <div class="feature-card">
                    <div class="feature-icon">🌐</div>
                    <h3 class="feature-title">Federated Registry</h3>
                    <p class="feature-description">
                        Sovereign registries form a peer-to-peer mesh network. Each registry maintains autonomy 
                        while seamlessly sharing agent discovery across the federation.
                    </p>
                    <div class="tech-stack">
                        <span class="tech-pill">HTTP/2</span>
                        <span class="tech-pill">Eventual Consistency</span>
                        <span class="tech-pill">Merkle Trees</span>
                    </div>
                </div>
                
                <div class="feature-card">
                    <div class="feature-icon">🛡️</div>
                    <h3 class="feature-title">Zero-Knowledge Proofs</h3>
                    <p class="feature-description">
                        Agents prove capabilities and attestations without revealing implementation details. 
                        Built on Groth16 for sub-100ms verification times.
                    </p>
                    <div class="tech-stack">
                        <span class="tech-pill">Groth16</span>
                        <span class="tech-pill">Circom</span>
                        <span class="tech-pill">Trusted Setup</span>
                    </div>
                </div>
                
                <div class="feature-card">
                    <div class="feature-icon">💎</div>
                    <h3 class="feature-title">Token Economic Graph</h3>
                    <p class="feature-description">
                        High-performance economic engine enabling instant value transfer between agents. 
                        No blockchain required - just cryptographic receipts and reputation scoring.
                    </p>
                    <div class="tech-stack">
                        <span class="tech-pill">Atomic Transfers</span>
                        <span class="tech-pill">Merkle Proofs</span>
                        <span class="tech-pill">Reputation Scoring</span>
                    </div>
                </div>
                
                <div class="feature-card">
                    <div class="feature-icon">🎯</div>
                    <h3 class="feature-title">Apex Predator Control</h3>
                    <p class="feature-description">
                        Risk-aware command execution system ensures even the most powerful agents operate 
                        within verifiable safety boundaries. Multi-step plans with approval workflows.
                    </p>
                    <div class="tech-stack">
                        <span class="tech-pill">OPA Policies</span>
                        <span class="tech-pill">Plan-based Execution</span>
                        <span class="tech-pill">Risk Scoring</span>
                    </div>
                </div>
                
                <div class="feature-card">
                    <div class="feature-icon">🚀</div>
                    <h3 class="feature-title">A2A Protocol</h3>
                    <p class="feature-description">
                        Agent-to-Agent communication protocol enabling autonomous task delegation, 
                        negotiation, and collaboration across the federated network.
                    </p>
                    <div class="tech-stack">
                        <span class="tech-pill">REST/JSON</span>
                        <span class="tech-pill">DID Auth</span>
                        <span class="tech-pill">E2E Encryption</span>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Code Examples -->
    <section>
        <div class="container">
            <div class="section-header">
                <h2 class="section-title">See It In Action</h2>
                <p class="section-subtitle">
                    Real code. Real performance. Real sovereignty.
                </p>
            </div>
            
            <div class="code-example">
                <pre><code><span class="comment"># Create and deploy an agent in 30 seconds</span>
<span class="keyword">from</span> theprotocol <span class="keyword">import</span> Registry, Agent

<span class="comment"># Connect to your sovereign registry</span>
registry = Registry(<span class="string">"https://your-registry.example.com"</span>)

<span class="comment"># Define your agent with capabilities</span>
agent = Agent(
    name=<span class="string">"DataAnalyzer"</span>,
    humanReadableId=<span class="string">"acme/analyzer"</span>,
    capabilities={
        <span class="string">"skills"</span>: [<span class="string">"nlp"</span>, <span class="string">"data-processing"</span>, <span class="string">"visualization"</span>],
        <span class="string">"compute"</span>: <span class="string">"gpu-enabled"</span>,
        <span class="string">"privacy"</span>: <span class="string">"zkp-attestations"</span>
    }
)

<span class="comment"># Deploy with automatic identity provisioning</span>
deployment = registry.deploy(agent)
print(f<span class="string">"Agent DID: {deployment.did}"</span>)  <span class="comment"># did:cosmos:silicon-valley:agent-7a3f</span>

<span class="comment"># Your agent is now discoverable across the entire federation!</span></code></pre>
            </div>
            
            <div class="code-example">
                <pre><code><span class="comment"># Cross-registry agent communication with automatic value transfer</span>
<span class="keyword">async def</span> delegate_task():
    <span class="comment"># Discover specialized agent across federation</span>
    translator = <span class="keyword">await</span> registry.discover(
        skill=<span class="string">"translation"</span>,
        language=<span class="string">"japanese"</span>
    )
    
    <span class="comment"># Send task with automatic payment</span>
    result = <span class="keyword">await</span> agent.send_task({
        <span class="string">"to"</span>: translator.did,
        <span class="string">"task"</span>: <span class="string">"translate"</span>,
        <span class="string">"data"</span>: <span class="string">"Hello, federated world!"</span>,
        <span class="string">"payment"</span>: <span class="string">"10 AVT"</span>  <span class="comment"># Automatic escrow and settlement</span>
    })
    
    <span class="comment"># Sub-second execution across registries!</span>
    print(f<span class="string">"Translation: {result.output}"</span>)
    print(f<span class="string">"Proof of work: {result.zkp_receipt}"</span>)</code></pre>
            </div>
        </div>
    </section>

    <!-- CTA Section -->
    <section class="cta-section">
        <div class="container">
            <div class="section-header">
                <h2 class="section-title">Ready to Build the Future?</h2>
                <p class="section-subtitle">
                    The infrastructure is live. The economics are proven.<br>
                    All that's missing is you.
                </p>
            </div>
            
            <div class="cta-buttons">
                <a href="/federation.html" class="btn-primary">Explore Federation Protocol</a>
                <a href="/developers-page.html" class="btn-secondary">Start Building</a>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="footer-content">
                <p>© 2025 The Protocol | <a href="/">Home</a> | <a href="/imprint.html">Imprint</a> | <a href="/privacy.html">Privacy</a></p>
            </div>
        </div>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Enhanced Live Federation Network Visualization
        const networkCanvas = document.getElementById('federation-network');
        const networkCtx = networkCanvas.getContext('2d');
        
        // Enhanced registry data with more properties - adjusted positions for better spacing
        const registries = [
            { name: 'Silicon Valley', x: 0.2, y: 0.25, color: '#3B82F6', agents: 7027, growth: 2.3, status: 'optimal', latency: '12ms' },
            { name: 'Tokyo', x: 0.8, y: 0.25, color: '#8B5CF6', agents: 4890, growth: 1.8, status: 'optimal', latency: '45ms' },
            { name: 'London', x: 0.2, y: 0.75, color: '#10B981', agents: 3431, growth: 3.1, status: 'growing', latency: '28ms' },
            { name: 'Singapore', x: 0.8, y: 0.75, color: '#EF4444', agents: 5234, growth: 2.7, status: 'optimal', latency: '35ms' },
            { name: 'Frankfurt', x: 0.5, y: 0.45, color: '#F59E0B', agents: 8123, growth: 1.5, status: 'optimal', latency: '18ms' }
        ];
        
        // Animation state
        let animationTime = 0;
        let mouseX = 0;
        let mouseY = 0;
        let hoveredRegistry = null;
        const particles = [];
        const connections = [];
        
        // Initialize connections
        for (let i = 0; i < registries.length; i++) {
            for (let j = i + 1; j < registries.length; j++) {
                connections.push({
                    from: i,
                    to: j,
                    packets: []
                });
                // Initialize data packets for each connection
                for (let k = 0; k < 3; k++) {
                    connections[connections.length - 1].packets.push({
                        progress: Math.random(),
                        speed: 0.3 + Math.random() * 0.4,
                        size: 2 + Math.random() * 2
                    });
                }
            }
        }
        
        // Background particles
        for (let i = 0; i < 50; i++) {
            particles.push({
                x: Math.random(),
                y: Math.random(),
                vx: (Math.random() - 0.5) * 0.0005,
                vy: (Math.random() - 0.5) * 0.0005,
                size: Math.random() * 2,
                opacity: Math.random() * 0.5
            });
        }
        
        function resizeNetworkCanvas() {
            const rect = networkCanvas.parentElement.getBoundingClientRect();
            networkCanvas.width = rect.width;
            networkCanvas.height = rect.height;
        }
        
        resizeNetworkCanvas();
        window.addEventListener('resize', resizeNetworkCanvas);
        
        // Mouse tracking
        networkCanvas.addEventListener('mousemove', (e) => {
            const rect = networkCanvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
            
            // Check hover on registries
            hoveredRegistry = null;
            registries.forEach((registry, index) => {
                const pos = getRegistryPos(registry);
                const dist = Math.sqrt(Math.pow(mouseX - pos.x, 2) + Math.pow(mouseY - pos.y, 2));
                const radius = getNodeRadius(registry);
                if (dist < radius + 20) {
                    hoveredRegistry = index;
                }
            });
        });
        
        networkCanvas.addEventListener('mouseleave', () => {
            hoveredRegistry = null;
        });
        
        // Convert relative positions to canvas coordinates with padding
        function getRegistryPos(registry) {
            const padding = 80; // Ensure nodes don't get cut off at edges
            return {
                x: padding + (registry.x * (networkCanvas.width - padding * 2)),
                y: padding + (registry.y * (networkCanvas.height - padding * 2))
            };
        }
        
        // Calculate node radius based on agent count
        function getNodeRadius(registry) {
            return Math.sqrt(registry.agents) * 0.8 + 20;
        }
        
        // Draw glowing line with gradient
        function drawGlowingLine(x1, y1, x2, y2, color, opacity = 0.3, width = 2) {
            // Glow effect
            networkCtx.strokeStyle = color + Math.floor(opacity * 255 / 4).toString(16).padStart(2, '0');
            networkCtx.lineWidth = width * 4;
            networkCtx.beginPath();
            networkCtx.moveTo(x1, y1);
            networkCtx.lineTo(x2, y2);
            networkCtx.stroke();
            
            // Main line
            networkCtx.strokeStyle = color + Math.floor(opacity * 255).toString(16).padStart(2, '0');
            networkCtx.lineWidth = width;
            networkCtx.beginPath();
            networkCtx.moveTo(x1, y1);
            networkCtx.lineTo(x2, y2);
            networkCtx.stroke();
        }
        
        // Draw enhanced node
        function drawNode(registry, index) {
            const pos = getRegistryPos(registry);
            const radius = getNodeRadius(registry);
            const isHovered = hoveredRegistry === index;
            const pulseScale = 1 + Math.sin(animationTime * 2 + index) * 0.05;
            const actualRadius = radius * (isHovered ? 1.1 : 1) * pulseScale;
            
            // Outer glow layers
            for (let i = 3; i > 0; i--) {
                const gradient = networkCtx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, actualRadius * (1 + i * 0.5));
                gradient.addColorStop(0, registry.color + '20');
                gradient.addColorStop(0.5, registry.color + '10');
                gradient.addColorStop(1, 'transparent');
                networkCtx.fillStyle = gradient;
                networkCtx.beginPath();
                networkCtx.arc(pos.x, pos.y, actualRadius * (1 + i * 0.5), 0, Math.PI * 2);
                networkCtx.fill();
            }
            
            // Main node gradient
            const nodeGradient = networkCtx.createRadialGradient(
                pos.x - actualRadius * 0.3, 
                pos.y - actualRadius * 0.3, 
                0, 
                pos.x, 
                pos.y, 
                actualRadius
            );
            nodeGradient.addColorStop(0, registry.color + 'FF');
            nodeGradient.addColorStop(0.7, registry.color + 'CC');
            nodeGradient.addColorStop(1, registry.color + '88');
            
            // Node shadow
            networkCtx.shadowColor = registry.color;
            networkCtx.shadowBlur = 20;
            networkCtx.fillStyle = nodeGradient;
            networkCtx.beginPath();
            networkCtx.arc(pos.x, pos.y, actualRadius, 0, Math.PI * 2);
            networkCtx.fill();
            networkCtx.shadowBlur = 0;
            
            // Inner bright core
            const coreGradient = networkCtx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, actualRadius * 0.3);
            coreGradient.addColorStop(0, '#FFFFFF');
            coreGradient.addColorStop(1, registry.color + 'AA');
            networkCtx.fillStyle = coreGradient;
            networkCtx.beginPath();
            networkCtx.arc(pos.x, pos.y, actualRadius * 0.3, 0, Math.PI * 2);
            networkCtx.fill();
            
            // Orbital ring
            if (isHovered || registry.status === 'optimal') {
                networkCtx.strokeStyle = registry.color + '60';
                networkCtx.lineWidth = 2;
                networkCtx.setLineDash([5, 5]);
                networkCtx.lineDashOffset = -animationTime * 50;
                networkCtx.beginPath();
                networkCtx.arc(pos.x, pos.y, actualRadius + 10, 0, Math.PI * 2);
                networkCtx.stroke();
                networkCtx.setLineDash([]);
            }
            
            // Text styling
            networkCtx.textAlign = 'center';
            networkCtx.textBaseline = 'middle';
            
            // Registry name with better styling
            networkCtx.font = `bold ${isHovered ? '16px' : '14px'} -apple-system, BlinkMacSystemFont, sans-serif`;
            networkCtx.fillStyle = '#FFFFFF';
            networkCtx.shadowColor = '#000000';
            networkCtx.shadowBlur = 4;
            networkCtx.fillText(registry.name, pos.x, pos.y - actualRadius - 25);
            
            // Agent count with formatting
            networkCtx.font = `${isHovered ? '14px' : '12px'} -apple-system, BlinkMacSystemFont, sans-serif`;
            networkCtx.fillStyle = registry.color;
            networkCtx.fillText(`${registry.agents.toLocaleString()} agents`, pos.x, pos.y - actualRadius - 40);
            
            // Growth and latency indicators
            if (isHovered) {
                networkCtx.font = '11px -apple-system, BlinkMacSystemFont, sans-serif';
                networkCtx.fillStyle = '#10B981';
                networkCtx.fillText(`↑ ${registry.growth}% growth`, pos.x, pos.y - actualRadius - 55);
                
                // Latency display - positioned to avoid overlap
                if (registry.name === 'Frankfurt') {
                    // Special positioning for center node - display above
                    networkCtx.textAlign = 'center';
                    networkCtx.fillStyle = '#3B82F6';
                    networkCtx.fillText(`⚡ ${registry.latency}`, pos.x, pos.y - actualRadius - 70);
                } else {
                    // Side positioning for other nodes
                    const latencyX = pos.x + (registry.x > 0.5 ? actualRadius + 30 : -actualRadius - 30);
                    networkCtx.textAlign = registry.x > 0.5 ? 'left' : 'right';
                    networkCtx.fillStyle = '#3B82F6';
                    networkCtx.fillText(`⚡ ${registry.latency}`, latencyX, pos.y);
                    networkCtx.textAlign = 'center'; // Reset alignment
                }
            }
            
            networkCtx.shadowBlur = 0;
            
            // Status indicator inside node with better styling
            networkCtx.font = 'bold 10px -apple-system, BlinkMacSystemFont, sans-serif';
            if (registry.status === 'optimal') {
                networkCtx.fillStyle = '#FFFFFF';
                networkCtx.fillText('OPTIMAL', pos.x, pos.y);
            } else if (registry.status === 'growing') {
                networkCtx.fillStyle = '#10B981';
                networkCtx.fillText('GROWING', pos.x, pos.y);
            }
            
            // Network strength indicator - compact version
            if (isHovered) {
                if (registry.name === 'Frankfurt') {
                    // For center node, show signal strength in the status area
                    networkCtx.font = '12px -apple-system, BlinkMacSystemFont, sans-serif';
                    networkCtx.fillStyle = '#10B981';
                    networkCtx.fillText('████', pos.x, pos.y + 15);
                } else {
                    // Side indicators for other nodes
                    const indicatorX = pos.x + (registry.x > 0.5 ? actualRadius + 15 : -actualRadius - 15);
                    const indicatorY = pos.y + 20;
                    
                    networkCtx.font = '14px -apple-system, BlinkMacSystemFont, sans-serif';
                    networkCtx.textAlign = registry.x > 0.5 ? 'left' : 'right';
                    const signalStrength = parseInt(registry.latency) < 30 ? '████' : parseInt(registry.latency) < 40 ? '███░' : '██░░';
                    networkCtx.fillStyle = parseInt(registry.latency) < 30 ? '#10B981' : parseInt(registry.latency) < 40 ? '#3B82F6' : '#F59E0B';
                    networkCtx.fillText(signalStrength, indicatorX, indicatorY);
                    networkCtx.textAlign = 'center'; // Reset
                }
            }
        }
        
        // Main animation loop
        function drawFederationNetwork() {
            // Clear canvas
            networkCtx.fillStyle = '#000000';
            networkCtx.fillRect(0, 0, networkCanvas.width, networkCanvas.height);
            
            // Animated grid background
            const gridSize = 50;
            const gridOffset = (animationTime * 10) % gridSize;
            
            networkCtx.strokeStyle = 'rgba(59, 130, 246, 0.03)';
            networkCtx.lineWidth = 1;
            
            // Vertical lines with subtle animation
            for (let x = -gridSize; x < networkCanvas.width + gridSize; x += gridSize) {
                const animX = x + gridOffset / 2;
                networkCtx.beginPath();
                networkCtx.moveTo(animX, 0);
                networkCtx.lineTo(animX, networkCanvas.height);
                networkCtx.stroke();
            }
            
            // Horizontal lines
            for (let y = 0; y < networkCanvas.height; y += gridSize) {
                networkCtx.beginPath();
                networkCtx.moveTo(0, y);
                networkCtx.lineTo(networkCanvas.width, y);
                networkCtx.stroke();
            }
            
            // Background particles
            particles.forEach(particle => {
                const x = particle.x * networkCanvas.width;
                const y = particle.y * networkCanvas.height;
                
                networkCtx.fillStyle = `rgba(59, 130, 246, ${particle.opacity})`;
                networkCtx.beginPath();
                networkCtx.arc(x, y, particle.size, 0, Math.PI * 2);
                networkCtx.fill();
                
                // Update particle position
                particle.x += particle.vx;
                particle.y += particle.vy;
                
                // Wrap around edges
                if (particle.x < 0) particle.x = 1;
                if (particle.x > 1) particle.x = 0;
                if (particle.y < 0) particle.y = 1;
                if (particle.y > 1) particle.y = 0;
            });
            
            // Draw connections with enhanced effects
            connections.forEach(conn => {
                const pos1 = getRegistryPos(registries[conn.from]);
                const pos2 = getRegistryPos(registries[conn.to]);
                
                // Connection strength based on hover
                const isConnectedToHover = hoveredRegistry === conn.from || hoveredRegistry === conn.to;
                const opacity = isConnectedToHover ? 0.6 : 0.2;
                
                // Calculate connection quality based on latency
                const avgLatency = (parseInt(registries[conn.from].latency) + parseInt(registries[conn.to].latency)) / 2;
                const connectionColor = avgLatency < 30 ? '#10B981' : avgLatency < 40 ? '#3B82F6' : '#F59E0B';
                
                // Draw connection line with quality color
                drawGlowingLine(pos1.x, pos1.y, pos2.x, pos2.y, connectionColor, opacity);
                
                // Animate data packets along connections
                conn.packets.forEach(packet => {
                    packet.progress += packet.speed * 0.01;
                    if (packet.progress > 1) {
                        packet.progress = 0;
                        packet.speed = 0.3 + Math.random() * 0.4;
                    }
                    
                    const packetX = pos1.x + (pos2.x - pos1.x) * packet.progress;
                    const packetY = pos1.y + (pos2.y - pos1.y) * packet.progress;
                    
                    // Packet trail
                    const trailLength = 5;
                    for (let i = 0; i < trailLength; i++) {
                        const trailProgress = Math.max(0, packet.progress - (i * 0.02));
                        const trailX = pos1.x + (pos2.x - pos1.x) * trailProgress;
                        const trailY = pos1.y + (pos2.y - pos1.y) * trailProgress;
                        const trailOpacity = (1 - i / trailLength) * 0.3;
                        
                        networkCtx.fillStyle = `rgba(59, 130, 246, ${trailOpacity})`;
                        networkCtx.beginPath();
                        networkCtx.arc(trailX, trailY, packet.size * (1 - i / trailLength), 0, Math.PI * 2);
                        networkCtx.fill();
                    }
                    
                    // Main packet with connection quality color
                    const packetGradient = networkCtx.createRadialGradient(packetX, packetY, 0, packetX, packetY, packet.size * 2);
                    packetGradient.addColorStop(0, '#FFFFFF');
                    packetGradient.addColorStop(0.5, connectionColor);
                    packetGradient.addColorStop(1, 'transparent');
                    
                    networkCtx.fillStyle = packetGradient;
                    networkCtx.beginPath();
                    networkCtx.arc(packetX, packetY, packet.size * 2, 0, Math.PI * 2);
                    networkCtx.fill();
                });
            });
            
            // Draw central hub indicator at Frankfurt's position
            const frankfurtPos = getRegistryPos(registries[4]); // Frankfurt is at index 4
            
            // Central pulse effect
            const pulseRadius = 25 + Math.sin(animationTime * 2) * 8;
            const pulseGradient = networkCtx.createRadialGradient(frankfurtPos.x, frankfurtPos.y, 0, frankfurtPos.x, frankfurtPos.y, pulseRadius);
            pulseGradient.addColorStop(0, 'rgba(245, 158, 11, 0.2)');
            pulseGradient.addColorStop(0.5, 'rgba(245, 158, 11, 0.1)');
            pulseGradient.addColorStop(1, 'transparent');
            
            networkCtx.fillStyle = pulseGradient;
            networkCtx.beginPath();
            networkCtx.arc(frankfurtPos.x, frankfurtPos.y, pulseRadius, 0, Math.PI * 2);
            networkCtx.fill();
            
            // Draw nodes on top
            registries.forEach((registry, index) => {
                drawNode(registry, index);
            });
            
            // Network title at the bottom
            networkCtx.font = 'bold 16px -apple-system, BlinkMacSystemFont, sans-serif';
            networkCtx.textAlign = 'center';
            networkCtx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            networkCtx.shadowColor = '#000000';
            networkCtx.shadowBlur = 4;
            networkCtx.fillText('LIVE FEDERATION NETWORK', networkCanvas.width / 2, networkCanvas.height - 20);
            networkCtx.shadowBlur = 0;
            
            // Update animation time
            animationTime += 0.016;
            requestAnimationFrame(drawFederationNetwork);
        }
        
        drawFederationNetwork();
        
        // 3D Architecture Visualization using Three.js
        // Wait for DOM to be ready
        function initArchitectureVisualization() {
            console.log('initArchitectureVisualization called');
            const architectureContainer = document.getElementById('architecture-canvas');
            if (!architectureContainer) {
                console.error('Architecture canvas not found');
                return;
            }
            console.log('Architecture container found:', architectureContainer);
            
            // Ensure container has dimensions
            const containerWidth = architectureContainer.clientWidth || architectureContainer.offsetWidth || 800;
            const containerHeight = architectureContainer.clientHeight || architectureContainer.offsetHeight || 700;
            console.log('Container dimensions:', containerWidth, 'x', containerHeight);
            
            if (containerWidth === 0 || containerHeight === 0) {
                console.error('Architecture container has no dimensions');
                setTimeout(initArchitectureVisualization, 100); // Retry after delay
                return;
            }
            
            // Clear any existing content
            architectureContainer.innerHTML = '';
            
            const scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000511, 15, 50);
            
            const camera = new THREE.PerspectiveCamera(60, containerWidth / containerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            
            renderer.setSize(containerWidth, containerHeight);
            renderer.setClearColor(0x000511, 1);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            architectureContainer.appendChild(renderer.domElement);
            console.log('Renderer created and appended successfully');
            
            // Enhanced Dramatic Lighting Setup
            const ambientLight = new THREE.AmbientLight(0x0a0a1a, 0.3);
            scene.add(ambientLight);
            
            // Key lights for dramatic effect
            const keyLight = new THREE.DirectionalLight(0x4080ff, 1.5);
            keyLight.position.set(10, 15, 10);
            keyLight.castShadow = true;
            keyLight.shadow.camera.near = 0.1;
            keyLight.shadow.camera.far = 50;
            keyLight.shadow.camera.left = -20;
            keyLight.shadow.camera.right = 20;
            keyLight.shadow.camera.top = 20;
            keyLight.shadow.camera.bottom = -20;
            keyLight.shadow.mapSize.width = 2048;
            keyLight.shadow.mapSize.height = 2048;
            scene.add(keyLight);
            
            // Rim light for edge highlighting
            const rimLight = new THREE.DirectionalLight(0x8B5CF6, 0.8);
            rimLight.position.set(-10, 5, -10);
            scene.add(rimLight);
            
            // Colored point lights for gem glow
            const pointLights = [];
            const lightColors = [0x3B82F6, 0x8B5CF6, 0x10B981, 0xF59E0B, 0xEF4444];
            lightColors.forEach((color, i) => {
                const light = new THREE.PointLight(color, 2, 25);
                pointLights.push(light);
                scene.add(light);
            });
            
            // Helper function to create glow sprite
            function createGlowSprite(color, size = 5) {
                const canvas = document.createElement('canvas');
                canvas.width = 128;
                canvas.height = 128;
                const context = canvas.getContext('2d');
                
                const gradient = context.createRadialGradient(64, 64, 0, 64, 64, 64);
                gradient.addColorStop(0, 'rgba(255,255,255,1)');
                gradient.addColorStop(0.1, 'rgba(255,255,255,0.9)');
                gradient.addColorStop(0.3, 'rgba(255,255,255,0.5)');
                gradient.addColorStop(0.6, 'rgba(255,255,255,0.1)');
                gradient.addColorStop(1, 'rgba(255,255,255,0)');
                
                context.fillStyle = gradient;
                context.fillRect(0, 0, 128, 128);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({
                    map: texture,
                    color: color,
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    opacity: 0.8
                });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.setScalar(size);
                return sprite;
            }

        
            // Create architecture components with gem-like visuals
            const components = [
                { name: 'Identity Fabric', color: 0x3B82F6, icon: '🔐', position: { x: -5, y: 2, z: 0 }, scale: 1.3, rotation: {x: 0.3, y: 0.5, z: 0} },
                { name: 'Federation', color: 0x8B5CF6, icon: '🌐', position: { x: 5, y: 2, z: 0 }, scale: 1.3, rotation: {x: -0.3, y: -0.5, z: 0} },
                { name: 'ZKP Layer', color: 0x10B981, icon: '🛡️', position: { x: -5, y: -2, z: 0 }, scale: 1.2, rotation: {x: 0.5, y: -0.3, z: 0.2} },
                { name: 'TEG Engine', color: 0xEF4444, icon: '💎', position: { x: 5, y: -2, z: 0 }, scale: 1.2, rotation: {x: -0.5, y: 0.3, z: -0.2} },
                { name: 'Apex Control', color: 0xF59E0B, icon: '🎯', position: { x: 0, y: 0, z: 2 }, scale: 1.6, rotation: {x: 0, y: 0, z: 0} }
            ];
            
            const gems = [];
            const gemGroup = new THREE.Group();
            
            // Create starfield background
            const starsGeometry = new THREE.BufferGeometry();
            const starsCount = 2000;
            const starPositions = new Float32Array(starsCount * 3);
            const starColors = new Float32Array(starsCount * 3);
            const starSizes = new Float32Array(starsCount);
            
            for (let i = 0; i < starsCount; i++) {
                const i3 = i * 3;
                starPositions[i3] = (Math.random() - 0.5) * 100;
                starPositions[i3 + 1] = (Math.random() - 0.5) * 100;
                starPositions[i3 + 2] = (Math.random() - 0.5) * 100;
                
                // Varied star colors
                const color = new THREE.Color();
                color.setHSL(Math.random() * 0.2 + 0.5, 0.5, Math.random() * 0.8 + 0.2);
                starColors[i3] = color.r;
                starColors[i3 + 1] = color.g;
                starColors[i3 + 2] = color.b;
                
                starSizes[i] = Math.random() * 2;
            }
            
            starsGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
            starsGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
            starsGeometry.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));
            
            const starsMaterial = new THREE.PointsMaterial({
                size: 0.1,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });
            
            const starField = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(starField);
            
            // Create floating platform
            const platformRadius = 10;
            const platformGeometry = new THREE.RingGeometry(platformRadius * 0.8, platformRadius, 64);
            const platformMaterial = new THREE.MeshPhongMaterial({
                color: 0x0a0a1a,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide,
                emissive: 0x3B82F6,
                emissiveIntensity: 0.05
            });
            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            platform.rotation.x = -Math.PI / 2;
            platform.position.y = -5;
            gemGroup.add(platform);
            
            // Create energy field lines on platform
            const lineCount = 12;
            for (let i = 0; i < lineCount; i++) {
                const angle = (i / lineCount) * Math.PI * 2;
                const innerRadius = 2;
                const outerRadius = platformRadius * 0.9;
                
                const points = [];
                points.push(new THREE.Vector3(Math.cos(angle) * innerRadius, -5, Math.sin(angle) * innerRadius));
                points.push(new THREE.Vector3(Math.cos(angle) * outerRadius, -5, Math.sin(angle) * outerRadius));
                
                const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                const lineMaterial = new THREE.LineBasicMaterial({
                    color: 0x3B82F6,
                    transparent: true,
                    opacity: 0.2
                });
                const line = new THREE.Line(lineGeometry, lineMaterial);
                gemGroup.add(line);
            }
            
            components.forEach((comp, index) => {
                const individualGemGroup = new THREE.Group();
                
                // Use different geometries for variety
                let gemGeometry;
                if (index === 4) { // Central Apex Control - larger, more complex
                    gemGeometry = new THREE.IcosahedronGeometry(comp.scale, 1);
                } else if (index % 2 === 0) {
                    gemGeometry = new THREE.OctahedronGeometry(comp.scale, 0);
                } else {
                    gemGeometry = new THREE.DodecahedronGeometry(comp.scale, 0);
                }
                
                // Crystal material with glass-like properties
                const gemMaterial = new THREE.MeshPhysicalMaterial({
                    color: comp.color,
                    metalness: 0.2,
                    roughness: 0.1,
                    transmission: 0.8,
                    transparent: true,
                    opacity: 0.9,
                    reflectivity: 0.9,
                    refractionRatio: 0.98,
                    clearcoat: 1,
                    clearcoatRoughness: 0,
                    emissive: comp.color,
                    emissiveIntensity: 0.2
                });
                
                const gem = new THREE.Mesh(gemGeometry, gemMaterial);
                gem.castShadow = true;
                gem.receiveShadow = true;
                
                // Apply initial rotation
                gem.rotation.x = comp.rotation.x;
                gem.rotation.y = comp.rotation.y;
                gem.rotation.z = comp.rotation.z;
                
                individualGemGroup.add(gem);
                
                // Inner glow core with matching geometry type
                let coreGeometry;
                if (index === 4) {
                    coreGeometry = new THREE.IcosahedronGeometry(comp.scale * 0.4, 1);
                } else if (index % 2 === 0) {
                    coreGeometry = new THREE.OctahedronGeometry(comp.scale * 0.4, 0);
                } else {
                    coreGeometry = new THREE.DodecahedronGeometry(comp.scale * 0.4, 0);
                }
                const coreMaterial = new THREE.MeshBasicMaterial({
                    color: 0xFFFFFF,
                    transparent: true,
                    opacity: 0.7
                });
                const core = new THREE.Mesh(coreGeometry, coreMaterial);
                individualGemGroup.add(core);
                
                // Outer wireframe for extra detail
                let wireframeGeometry;
                if (index === 4) {
                    wireframeGeometry = new THREE.IcosahedronGeometry(comp.scale * 1.1, 1);
                } else if (index % 2 === 0) {
                    wireframeGeometry = new THREE.OctahedronGeometry(comp.scale * 1.1, 0);
                } else {
                    wireframeGeometry = new THREE.DodecahedronGeometry(comp.scale * 1.1, 0);
                }
                const wireframeMaterial = new THREE.MeshBasicMaterial({
                    color: comp.color,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.2
                });
                const wireframe = new THREE.Mesh(wireframeGeometry, wireframeMaterial);
                individualGemGroup.add(wireframe);
                
                // Energy particles around gem
                const particleCount = 20;
                const particlesGeometry = new THREE.BufferGeometry();
                const particlePositions = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    const angle = (i / particleCount) * Math.PI * 2;
                    const radius = comp.scale * 2 + Math.random() * 0.5;
                    particlePositions[i * 3] = Math.cos(angle) * radius;
                    particlePositions[i * 3 + 1] = (Math.random() - 0.5) * comp.scale;
                    particlePositions[i * 3 + 2] = Math.sin(angle) * radius;
                }
                
                particlesGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
                
                const particlesMaterial = new THREE.PointsMaterial({
                    color: comp.color,
                    size: 0.1,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending
                });
                
                const particles = new THREE.Points(particlesGeometry, particlesMaterial);
                individualGemGroup.add(particles);
                
                // Add multiple glow sprites for enhanced effect
                const glowSprite1 = createGlowSprite(comp.color, comp.scale * 4);
                individualGemGroup.add(glowSprite1);
                
                const glowSprite2 = createGlowSprite(0xFFFFFF, comp.scale * 2);
                glowSprite2.material.opacity = 0.3;
                individualGemGroup.add(glowSprite2);
                
                // Position light at gem location
                if (pointLights[index]) {
                    pointLights[index].position.set(comp.position.x, comp.position.y, comp.position.z);
                }
                
                // Position the individual gem group
                individualGemGroup.position.set(comp.position.x, comp.position.y, comp.position.z);
                gemGroup.add(individualGemGroup);
                
                gems.push({
                    mesh: gem,
                    group: individualGemGroup,
                    component: comp,
                    core: core,
                    wireframe: wireframe,
                    particles: particles,
                    particlesGeometry: particlesGeometry
                });
            });
            
            scene.add(gemGroup);
            
            // Create energy beams between gems
            const beamMaterial = new THREE.MeshBasicMaterial({
                color: 0x3B82F6,
                transparent: true,
                opacity: 0.1,
                side: THREE.DoubleSide
            });
            
            const beams = [];
            for (let i = 0; i < gems.length; i++) {
                for (let j = i + 1; j < gems.length; j++) {
                    if (Math.abs(i - j) === 1 || (i === 0 && j === gems.length - 1) || (i === gems.length - 1 && j === 0)) {
                        const startPos = gems[i].component.position;
                        const endPos = gems[j].component.position;
                        const start = new THREE.Vector3(startPos.x, startPos.y, startPos.z);
                        const end = new THREE.Vector3(endPos.x, endPos.y, endPos.z);
                        
                        const distance = start.distanceTo(end);
                        const beamGeometry = new THREE.CylinderGeometry(0.02, 0.02, distance, 8);
                        const beam = new THREE.Mesh(beamGeometry, beamMaterial);
                        
                        // Position and orient the beam
                        const midpoint = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
                        beam.position.copy(midpoint);
                        
                        const direction = new THREE.Vector3().subVectors(end, start).normalize();
                        const axis = new THREE.Vector3(0, 1, 0);
                        const quaternion = new THREE.Quaternion().setFromUnitVectors(axis, direction);
                        beam.quaternion.copy(quaternion);
                        
                        gemGroup.add(beam);
                        beams.push({ mesh: beam, start: i, end: j });
                    }
                }
            }
        
            // Create flowing energy particles
            const flowParticles = [];
            const flowParticleCount = 100;
            
            for (let i = 0; i < flowParticleCount; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.05, 6, 6);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00D4FF,
                    transparent: true,
                    opacity: 0.8
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // Random initial position
                particle.position.x = (Math.random() - 0.5) * 20;
                particle.position.y = (Math.random() - 0.5) * 10;
                particle.position.z = (Math.random() - 0.5) * 20;
                
                // Random velocity
                particle.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.02,
                        (Math.random() - 0.5) * 0.02,
                        (Math.random() - 0.5) * 0.02
                    ),
                    lifespan: Math.random() * 2 + 1
                };
                
                gemGroup.add(particle);
                flowParticles.push(particle);
            }
            
            // Set camera position for optimal view
            camera.position.set(0, 3, 20);
            camera.lookAt(0, 0, 0);
            
            // Mouse interaction variables
            let mouseX = 0;
            let mouseY = 0;
            let targetRotationX = 0;
            let targetRotationY = 0;
            const windowHalfX = containerWidth / 2;
            const windowHalfY = containerHeight / 2;
            
            // Mouse move handler
            function onMouseMove(event) {
                const rect = architectureContainer.getBoundingClientRect();
                mouseX = ((event.clientX - rect.left) - windowHalfX) / windowHalfX;
                mouseY = ((event.clientY - rect.top) - windowHalfY) / windowHalfY;
            }
            
            architectureContainer.addEventListener('mousemove', onMouseMove, false);
            
            // Animation loop
            function animate3D() {
                requestAnimationFrame(animate3D);
                
                // Smooth camera rotation based on mouse
                targetRotationY = mouseX * 0.3;
                targetRotationX = -mouseY * 0.2;
                gemGroup.rotation.y += (targetRotationY - gemGroup.rotation.y) * 0.05;
                gemGroup.rotation.x += (targetRotationX - gemGroup.rotation.x) * 0.05;
                
                // Animate gem components
                gems.forEach((gemData, index) => {
                    const time = Date.now() * 0.001;
                    
                    // Slow rotation for gems
                    gemData.mesh.rotation.y += 0.005;
                    gemData.mesh.rotation.x += 0.002;
                    
                    // Float animation
                    gemData.group.position.y = gemData.component.position.y + Math.sin(time * 0.5 + index) * 0.3;
                    
                    // Pulse core
                    const corePulse = 0.5 + Math.sin(time * 2 + index) * 0.1;
                    gemData.core.scale.setScalar(corePulse);
                    
                    // Wireframe rotation effect
                    const wireframeScale = 1.1 + Math.sin(time * 1.5 + index * 0.5) * 0.05;
                    gemData.wireframe.scale.setScalar(wireframeScale);
                    gemData.wireframe.rotation.y -= 0.002;
                    
                    // Rotate energy particles
                    gemData.particles.rotation.y += 0.01;
                    
                    // Update particle positions for orbital motion
                    const positions = gemData.particlesGeometry.attributes.position.array;
                    const particleCount = positions.length / 3;
                    
                    for (let i = 0; i < particleCount; i++) {
                        const angle = (i / particleCount) * Math.PI * 2 + time * 0.5;
                        const radius = gemData.component.scale * 2 + Math.sin(time * 2 + i) * 0.5;
                        positions[i * 3] = Math.cos(angle) * radius;
                        positions[i * 3 + 2] = Math.sin(angle) * radius;
                    }
                    
                    gemData.particlesGeometry.attributes.position.needsUpdate = true;
                    
                    // Update point light intensity
                    if (pointLights[index]) {
                        pointLights[index].intensity = 2 + Math.sin(time * 3 + index) * 0.5;
                    }
                });
                
                // Animate energy beams
                beams.forEach((beam, index) => {
                    const time = Date.now() * 0.001;
                    beam.mesh.material.opacity = 0.05 + Math.sin(time * 2 + index) * 0.03;
                });
                
                // Animate flow particles
                const currentTime = Date.now() * 0.001;
                flowParticles.forEach((particle, index) => {
                    // Update position
                    particle.position.add(particle.userData.velocity);
                    
                    // Apply attraction to nearest gem
                    let nearestDist = Infinity;
                    let nearestGem = null;
                    
                    gems.forEach(gem => {
                        const dist = particle.position.distanceTo(gem.group.position);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestGem = gem;
                        }
                    });
                    
                    if (nearestGem && nearestDist < 10) {
                        const attraction = nearestGem.group.position.clone().sub(particle.position).normalize().multiplyScalar(0.001);
                        particle.userData.velocity.add(attraction);
                    }
                    
                    // Respawn if too far
                    if (particle.position.length() > 15) {
                        particle.position.x = (Math.random() - 0.5) * 20;
                        particle.position.y = (Math.random() - 0.5) * 10;
                        particle.position.z = (Math.random() - 0.5) * 20;
                        particle.userData.velocity = new THREE.Vector3(
                            (Math.random() - 0.5) * 0.02,
                            (Math.random() - 0.5) * 0.02,
                            (Math.random() - 0.5) * 0.02
                        );
                    }
                    
                    // Fade based on lifespan
                    particle.material.opacity = 0.8 * Math.sin(currentTime + index);
                });
                
                // Rotate star field slowly
                starField.rotation.y += 0.0001;
                starField.rotation.x += 0.00005;
                
                // Update platform glow
                const platformTime = Date.now() * 0.001;
                platform.material.emissiveIntensity = 0.05 + Math.sin(platformTime) * 0.02;
                
                renderer.render(scene, camera);
            }
        
            animate3D();
            
            // Handle resize
            window.addEventListener('resize', () => {
                if (architectureContainer && camera && renderer) {
                    const newWidth = architectureContainer.clientWidth || architectureContainer.offsetWidth || 800;
                    const newHeight = architectureContainer.clientHeight || architectureContainer.offsetHeight || 700;
                    camera.aspect = newWidth / newHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(newWidth, newHeight);
                }
            });
        }
        
        // Initialize 3D visualization when DOM is ready
        function tryInitArchitecture() {
            console.log('Trying to initialize architecture visualization...');
            if (typeof THREE === 'undefined') {
                console.error('Three.js not loaded yet, retrying...');
                setTimeout(tryInitArchitecture, 100);
                return;
            }
            console.log('Three.js is loaded, version:', THREE.REVISION);
            initArchitectureVisualization();
        }
        
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', tryInitArchitecture);
        } else {
            // Give a small delay to ensure Three.js is fully loaded
            setTimeout(tryInitArchitecture, 100);
        }
        
        // Mobile Navigation Toggle
        const navToggle = document.getElementById('navToggle');
        const navMenu = document.getElementById('navMenu');
        
        navToggle.addEventListener('click', function() {
            navToggle.classList.toggle('active');
            navMenu.classList.toggle('active');
        });
        
        // Close mobile menu when clicking a link
        document.querySelectorAll('.nav-link').forEach(link => {
            link.addEventListener('click', function() {
                navToggle.classList.remove('active');
                navMenu.classList.remove('active');
            });
        });
        
        // Header scroll effect
        let lastScroll = 0;
        const header = document.querySelector('.nav-header');
        
        window.addEventListener('scroll', () => {
            const currentScroll = window.pageYOffset;
            
            if (currentScroll <= 0) {
                header.style.boxShadow = 'none';
            } else {
                header.style.boxShadow = '0 2px 20px rgba(0, 0, 0, 0.5)';
            }
            
            lastScroll = currentScroll;
        });
        
        // Smooth scrolling
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    const offsetTop = target.offsetTop - 80; // Account for fixed header
                    window.scrollTo({
                        top: offsetTop,
                        behavior: 'smooth'
                    });
                }
            });
        });

        // Developer Portal button placeholder
        document.querySelector('.nav-dev-portal').addEventListener('click', function(e) {
            e.preventDefault();
            alert('Developer Portal coming soon! The registry frontend will be available after the public beta launch.');
        });
    </script>
</body>
</html>